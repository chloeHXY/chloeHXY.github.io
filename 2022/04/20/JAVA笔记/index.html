<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Chloe HXY">





<title>Java note | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Chloehxy&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/categories/Technology">Technology</a>
                
                    <a class="menu-item" href="/categories/Literature">Literature</a>
                
                    <a class="menu-item" href="/categories/PM">PM</a>
                
                    <a class="menu-item" href="/categories/IELTS">IELTS</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Chloehxy&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/categories/Technology">Technology</a>
                
                    <a class="menu-item" href="/categories/Literature">Literature</a>
                
                    <a class="menu-item" href="/categories/PM">PM</a>
                
                    <a class="menu-item" href="/categories/IELTS">IELTS</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Java note</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Chloe HXY</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">April 20, 2022&nbsp;&nbsp;0:00:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Technology/">Technology</a>
                            
                                <a href="/categories/Technology/Language/">Language</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>tips:查看一个类的Api可以通过选中该类然后ctrl+单击<br>Switch可以对字符串进行判段选择</p>
<h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//replaceAll 替换此字符串所有匹配给定的正则表达式的子字符串</span></span><br><span class="line"><span class="comment">//去除所有空格</span></span><br><span class="line">String reString=datString.replaceAll(<span class="string">&quot;\\s+&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">一、校验数字的表达式</span><br><span class="line">    </span><br><span class="line"><span class="number">1</span> 数字：^[<span class="number">0</span><span class="number">-9</span>]*$</span><br><span class="line"><span class="number">2</span> n位的数字：^\d&#123;n&#125;$</span><br><span class="line"><span class="number">3</span> 至少n位的数字：^\d&#123;n,&#125;$</span><br><span class="line"><span class="number">4</span> m-n位的数字：^\d&#123;m,n&#125;$</span><br><span class="line"><span class="number">5</span> 零和非零开头的数字：^(<span class="number">0</span>|[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)$</span><br><span class="line"><span class="number">6</span> 非零开头的最多带两位小数的数字：^([<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)+(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)?$</span><br><span class="line"><span class="number">7</span> 带<span class="number">1</span><span class="number">-2</span>位小数的正数或负数：^(\-)?\d+(\.\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)?$</span><br><span class="line"><span class="number">8</span> 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$</span><br><span class="line"><span class="number">9</span> 有两位小数的正实数：^[<span class="number">0</span><span class="number">-9</span>]+(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">2</span>&#125;)?$</span><br><span class="line"><span class="number">10</span> 有<span class="number">1</span>~<span class="number">3</span>位小数的正实数：^[<span class="number">0</span><span class="number">-9</span>]+(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">3</span>&#125;)?$</span><br><span class="line"><span class="number">11</span> 非零的正整数：^[<span class="number">1</span><span class="number">-9</span>]\d*$ 或 ^([<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)&#123;<span class="number">1</span>,<span class="number">3</span>&#125;$ 或 ^\+?[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*$</span><br><span class="line"><span class="number">12</span> 非零的负整数：^\-[<span class="number">1</span><span class="number">-9</span>][]<span class="number">0</span><span class="number">-9</span>&quot;*$ 或 ^-[<span class="number">1</span><span class="number">-9</span>]\d*$</span><br><span class="line"><span class="number">13</span> 非负整数：^\d+$ 或 ^[<span class="number">1</span><span class="number">-9</span>]\d*|<span class="number">0</span>$</span><br><span class="line"><span class="number">14</span> 非正整数：^-[<span class="number">1</span><span class="number">-9</span>]\d*|<span class="number">0</span>$ 或 ^((-\d+)|(<span class="number">0</span>+))$</span><br><span class="line"><span class="number">15</span> 非负浮点数：^\d+(\.\d+)?$ 或 ^[<span class="number">1</span><span class="number">-9</span>]\d*\.\d*|<span class="number">0</span>\.\d*[<span class="number">1</span><span class="number">-9</span>]\d*|<span class="number">0</span>?\<span class="number">.0</span>+|<span class="number">0</span>$</span><br><span class="line"><span class="number">16</span> 非正浮点数：^((-\d+(\.\d+)?)|(<span class="number">0</span>+(\<span class="number">.0</span>+)?))$ 或 ^(-([<span class="number">1</span><span class="number">-9</span>]\d*\.\d*|<span class="number">0</span>\.\d*[<span class="number">1</span><span class="number">-9</span>]\d*))|<span class="number">0</span>?\<span class="number">.0</span>+|<span class="number">0</span>$</span><br><span class="line"><span class="number">17</span> 正浮点数：^[<span class="number">1</span><span class="number">-9</span>]\d*\.\d*|<span class="number">0</span>\.\d*[<span class="number">1</span><span class="number">-9</span>]\d*$ 或 ^(([<span class="number">0</span><span class="number">-9</span>]+\.[<span class="number">0</span><span class="number">-9</span>]*[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)|([<span class="number">0</span><span class="number">-9</span>]*[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*\.[<span class="number">0</span><span class="number">-9</span>]+)|([<span class="number">0</span><span class="number">-9</span>]*[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*))$</span><br><span class="line"><span class="number">18</span> 负浮点数：^-([<span class="number">1</span><span class="number">-9</span>]\d*\.\d*|<span class="number">0</span>\.\d*[<span class="number">1</span><span class="number">-9</span>]\d*)$ 或 ^(-(([<span class="number">0</span><span class="number">-9</span>]+\.[<span class="number">0</span><span class="number">-9</span>]*[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)|([<span class="number">0</span><span class="number">-9</span>]*[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*\.[<span class="number">0</span><span class="number">-9</span>]+)|([<span class="number">0</span><span class="number">-9</span>]*[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)))$</span><br><span class="line"><span class="number">19</span> 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([<span class="number">1</span><span class="number">-9</span>]\d*\.\d*|<span class="number">0</span>\.\d*[<span class="number">1</span><span class="number">-9</span>]\d*|<span class="number">0</span>?\<span class="number">.0</span>+|<span class="number">0</span>)$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二、校验字符的表达式</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> 汉字：^[\u4e00-\u9fa5]&#123;<span class="number">0</span>,&#125;$</span><br><span class="line"><span class="number">2</span> 英文和数字：^[A-Za-z0<span class="number">-9</span>]+$ 或 ^[A-Za-z0<span class="number">-9</span>]&#123;<span class="number">4</span>,<span class="number">40</span>&#125;$</span><br><span class="line"><span class="number">3</span> 长度为<span class="number">3</span><span class="number">-20</span>的所有字符：^.&#123;<span class="number">3</span>,<span class="number">20</span>&#125;$</span><br><span class="line"><span class="number">4</span> 由<span class="number">26</span>个英文字母组成的字符串：^[A-Za-z]+$</span><br><span class="line"><span class="number">5</span> 由<span class="number">26</span>个大写英文字母组成的字符串：^[A-Z]+$</span><br><span class="line"><span class="number">6</span> 由<span class="number">26</span>个小写英文字母组成的字符串：^[a-z]+$</span><br><span class="line"><span class="number">7</span> 由数字和<span class="number">26</span>个英文字母组成的字符串：^[A-Za-z0<span class="number">-9</span>]+$</span><br><span class="line"><span class="number">8</span> 由数字、<span class="number">26</span>个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;<span class="number">3</span>,<span class="number">20</span>&#125;$</span><br><span class="line"><span class="number">9</span> 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0<span class="number">-9</span>_]+$</span><br><span class="line"><span class="number">10</span> 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0<span class="number">-9</span>]+$ 或 ^[\u4E00-\u9FA5A-Za-z0<span class="number">-9</span>]&#123;<span class="number">2</span>,<span class="number">20</span>&#125;$</span><br><span class="line"><span class="number">11</span> 可以输入含有^%&amp;&#x27;,;=?$\&quot;等字符：[^%&amp;&#x27;,;=?$\x22]+</span><br><span class="line"><span class="number">12</span> 禁止输入含有~的字符：[^~\x22]+</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">三、特殊需求表达式</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span><br><span class="line"><span class="number">2</span> 域名：[a-zA-Z0<span class="number">-9</span>][-a-zA-Z0<span class="number">-9</span>]&#123;<span class="number">0</span>,<span class="number">62</span>&#125;(/.[a-zA-Z0<span class="number">-9</span>][-a-zA-Z0<span class="number">-9</span>]&#123;<span class="number">0</span>,<span class="number">62</span>&#125;)+/.?</span><br><span class="line"><span class="number">3</span> InternetURL：[a-zA-z]+:<span class="comment">//[^\s]* 或 ^https://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</span></span><br><span class="line"><span class="number">4</span> 手机号码：^(<span class="number">13</span>[<span class="number">0</span><span class="number">-9</span>]|<span class="number">14</span>[<span class="number">5</span>|<span class="number">7</span>]|<span class="number">15</span>[<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span>]|<span class="number">18</span>[<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span>])\d&#123;<span class="number">8</span>&#125;$</span><br><span class="line"><span class="number">5</span> 电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\(\d&#123;<span class="number">3</span>,<span class="number">4</span>&#125;-)|\d&#123;<span class="number">3.4</span>&#125;-)?\d&#123;<span class="number">7</span>,<span class="number">8</span>&#125;$ </span><br><span class="line"><span class="number">6</span> 国内电话号码(<span class="number">0511</span><span class="number">-4405222</span>、<span class="number">021</span><span class="number">-87888822</span>)：\d&#123;<span class="number">3</span>&#125;-\d&#123;<span class="number">8</span>&#125;|\d&#123;<span class="number">4</span>&#125;-\d&#123;<span class="number">7</span>&#125;</span><br><span class="line"><span class="number">7</span> 身份证号：</span><br><span class="line">		<span class="number">15</span>或<span class="number">18</span>位身份证：^\d&#123;<span class="number">15</span>&#125;|\d&#123;<span class="number">18</span>&#125;$</span><br><span class="line">		<span class="number">15</span>位身份证：^[<span class="number">1</span><span class="number">-9</span>]\d&#123;<span class="number">7</span>&#125;((<span class="number">0</span>\d)|(<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>]))(([<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>]\d)|<span class="number">3</span>[<span class="number">0</span><span class="number">-1</span>])\d&#123;<span class="number">3</span>&#125;$</span><br><span class="line">		<span class="number">18</span>位身份证：^[<span class="number">1</span><span class="number">-9</span>]\d&#123;<span class="number">5</span>&#125;[<span class="number">1</span><span class="number">-9</span>]\d&#123;<span class="number">3</span>&#125;((<span class="number">0</span>\d)|(<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>]))(([<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>]\d)|<span class="number">3</span>[<span class="number">0</span><span class="number">-1</span>])\d&#123;<span class="number">4</span>&#125;$</span><br><span class="line"><span class="number">8</span> 短身份证号码(数字、字母x结尾)：^([<span class="number">0</span><span class="number">-9</span>])&#123;<span class="number">7</span>,<span class="number">18</span>&#125;(x|X)?$ 或 ^\d&#123;<span class="number">8</span>,<span class="number">18</span>&#125;|[<span class="number">0</span><span class="number">-9</span>x]&#123;<span class="number">8</span>,<span class="number">18</span>&#125;|[<span class="number">0</span><span class="number">-9</span>X]&#123;<span class="number">8</span>,<span class="number">18</span>&#125;?$</span><br><span class="line"><span class="number">9</span> 帐号是否合法(字母开头，允许<span class="number">5</span><span class="number">-16</span>字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0<span class="number">-9</span>_]&#123;<span class="number">4</span>,<span class="number">15</span>&#125;$</span><br><span class="line"><span class="number">10</span> 密码(以字母开头，长度在<span class="number">6</span>~<span class="number">18</span>之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;<span class="number">5</span>,<span class="number">17</span>&#125;$</span><br><span class="line"><span class="number">11</span> 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在<span class="number">8</span><span class="number">-10</span>之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;<span class="number">8</span>,<span class="number">10</span>&#125;$ </span><br><span class="line"><span class="number">12</span> 日期格式：^\d&#123;<span class="number">4</span>&#125;-\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;-\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="number">13</span> 一年的<span class="number">12</span>个月(<span class="number">01</span>～<span class="number">09</span>和<span class="number">1</span>～<span class="number">12</span>)：^(<span class="number">0</span>?[<span class="number">1</span><span class="number">-9</span>]|<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>])$</span><br><span class="line"><span class="number">14</span> 一个月的<span class="number">31</span>天(<span class="number">01</span>～<span class="number">09</span>和<span class="number">1</span>～<span class="number">31</span>)：^((<span class="number">0</span>?[<span class="number">1</span><span class="number">-9</span>])|((<span class="number">1</span>|<span class="number">2</span>)[<span class="number">0</span><span class="number">-9</span>])|<span class="number">30</span>|<span class="number">31</span>)$ </span><br><span class="line"><span class="number">15</span> 钱的输入格式：</span><br><span class="line"><span class="number">16</span> <span class="number">1.</span>有四种钱的表示形式我们可以接受:&quot;<span class="number">10000.00</span>&quot; 和 &quot;<span class="number">10</span>,<span class="number">000.00</span>&quot;, 和没有 &quot;分&quot; 的 &quot;<span class="number">10000</span>&quot; 和 &quot;<span class="number">10</span>,<span class="number">000</span>&quot;：^[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*$ </span><br><span class="line"><span class="number">17</span> <span class="number">2.</span>这表示任意一个不以<span class="number">0</span>开头的数字,但是,这也意味着一个字符&quot;<span class="number">0</span>&quot;不通过,所以我们采用下面的形式：^(<span class="number">0</span>|[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)$ </span><br><span class="line"><span class="number">18</span> <span class="number">3.</span>一个<span class="number">0</span>或者一个不以<span class="number">0</span>开头的数字.我们还可以允许开头有一个负号：^(<span class="number">0</span>|-?[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)$ </span><br><span class="line"><span class="number">19</span> <span class="number">4.</span>这表示一个<span class="number">0</span>或者一个可能为负的开头不为<span class="number">0</span>的数字.让用户以<span class="number">0</span>开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[<span class="number">0</span><span class="number">-9</span>]+(.[<span class="number">0</span><span class="number">-9</span>]+)?$ </span><br><span class="line"><span class="number">20</span> <span class="number">5.</span>必须说明的是,小数点后面至少应该有<span class="number">1</span>位数,所以&quot;<span class="number">10.</span>&quot;是不通过的,但是 &quot;<span class="number">10</span>&quot; 和 &quot;<span class="number">10.2</span>&quot; 是通过的：^[<span class="number">0</span><span class="number">-9</span>]+(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">2</span>&#125;)?$ </span><br><span class="line"><span class="number">21</span> <span class="number">6.</span>这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[<span class="number">0</span><span class="number">-9</span>]+(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)?$ </span><br><span class="line"><span class="number">22</span> <span class="number">7.</span>这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">3</span>&#125;(,[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">3</span>&#125;)*(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)?$ </span><br><span class="line"><span class="number">23</span> <span class="number">8.1</span>到<span class="number">3</span>个数字,后面跟着任意个 逗号+<span class="number">3</span>个数字,逗号成为可选,而不是必须：^([<span class="number">0</span><span class="number">-9</span>]+|[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">3</span>&#125;(,[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">3</span>&#125;)*)(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)?$ </span><br><span class="line"><span class="number">24</span> 备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</span><br><span class="line"><span class="number">25</span> xml文件：^([a-zA-Z]+-?)+[a-zA-Z0<span class="number">-9</span>]+\\.[x|X][m|M][l|L]$</span><br><span class="line"><span class="number">26</span> 中文字符的正则表达式：[\u4e00-\u9fa5]</span><br><span class="line"><span class="number">27</span> 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计<span class="number">2</span>，ASCII字符计<span class="number">1</span>))</span><br><span class="line"><span class="number">28</span> 空白行的正则表达式：\n\s*\r (可以用来删除空白行)</span><br><span class="line"><span class="number">29</span> HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</span><br><span class="line"><span class="number">30</span> 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</span><br><span class="line"><span class="number">31</span> 腾讯QQ号：[<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">4</span>,&#125; (腾讯QQ号从<span class="number">10000</span>开始)</span><br><span class="line"><span class="number">32</span> 中国邮政编码：[<span class="number">1</span><span class="number">-9</span>]\d&#123;<span class="number">5</span>&#125;(?!\d) (中国邮政编码为<span class="number">6</span>位数字)</span><br><span class="line"><span class="number">33</span> IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="正则的使用"><a href="#正则的使用" class="headerlink" title="正则的使用"></a>正则的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String regex=<span class="string">&quot;ha&quot;</span>;</span><br><span class="line">String input=<span class="string">&quot;haha&quot;</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span>Pattern.compile(regex); <span class="comment">//正则字符串需要编译为Pattern类的实例</span></span><br><span class="line"><span class="comment">//用此实例创建Mather对象，从而与任意字符串进行想要的匹配</span></span><br><span class="line">Mather m=p.matcher(input);</span><br><span class="line">m.matches();<span class="comment">//是否整个序列都匹配 返回false</span></span><br><span class="line">m.lookingAt(); <span class="comment">//从第一个字符开始匹配是否有能够匹配到的 返回true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h1 id="2023补充知识"><a href="#2023补充知识" class="headerlink" title="2023补充知识"></a>2023补充知识</h1><h2 id="二维矩阵问题"><a href="#二维矩阵问题" class="headerlink" title="二维矩阵问题"></a>二维矩阵问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二维矩阵arr</span></span><br><span class="line"><span class="comment">1 2 3</span></span><br><span class="line"><span class="comment">4 5 6</span></span><br><span class="line"><span class="comment">7 8 9</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;la;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;la;j++)&#123;</span><br><span class="line">      arr[i][j] <span class="comment">// 1 2 3 4 5 6</span></span><br><span class="line">      arr[j][i] <span class="comment">//这里把i当做列坐标，j当做行坐标 1 4 7 2 5 8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们仅仅可以只使用一次遍历，同时获取行数据、列数据。</p>
<p>从而可以进行一些其他操作，如：获得各行的最大值，和各列的最大值</p>
<h1 id="2022补充知识"><a href="#2022补充知识" class="headerlink" title="2022补充知识"></a>2022补充知识</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="1-定义栈"><a href="#1-定义栈" class="headerlink" title="1.定义栈"></a>1.定义栈</h3><p>​    Stack&lt;栈中的数据类型&gt; name&#x3D;new Stack&lt;&gt;();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack; <span class="comment">//存在于Java.util包中，需要引入</span></span><br><span class="line">Stack&lt;<span class="type">int</span>&gt; sta=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="2-栈中常用方法"><a href="#2-栈中常用方法" class="headerlink" title="2.栈中常用方法"></a>2.栈中常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sta.push(<span class="number">3</span>); <span class="comment">//向栈中打入数据3</span></span><br><span class="line">sta.pop();   <span class="comment">//弹出一个数据</span></span><br><span class="line">sta.isEmpty(); <span class="comment">//返回一个bool值 表示栈是否为空</span></span><br><span class="line">sta.peek(); <span class="comment">//返回栈顶数据但不移除！！</span></span><br></pre></td></tr></table></figure>

<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><strong>本质:存储Key –value键值对的对象</strong></p>
<p><strong>注意 HashMap和HashSet都是无序的，不会记录插入顺序</strong></p>
<p>比起数组，链表需要按序查找的局限，哈希表具有索引直取的优良特性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap; <span class="comment">//存在于Java.util包中，需要引入</span></span><br><span class="line"><span class="comment">//HashMap 中的元素实际上是对象，一些常见的基本类型可以使用它的包装类。</span></span><br><span class="line">HashMap&lt;Integer,String&gt;Sites=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,String&gt;();</span><br><span class="line"><span class="comment">//put添加键值对</span></span><br><span class="line">Sites.put(<span class="number">1</span>,<span class="string">&quot;feel&quot;</span>);</span><br><span class="line">Sites.put(<span class="number">2</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(Sites);<span class="comment">//&#123;1=feel,2=hello&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//键与值也可以取其他类型：</span></span><br><span class="line">HashMap&lt;String,String&gt; Sites=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">Sites.put(<span class="string">&quot;yy&quot;</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">Sites.put(<span class="string">&quot;xx&quot;</span>,<span class="string">&quot;helllll&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过key操作数据</span></span><br><span class="line"><span class="comment">//get查询元素</span></span><br><span class="line">System.out.println(Sites.get(<span class="string">&quot;yy&quot;</span>)) ;<span class="comment">//hello</span></span><br><span class="line"><span class="comment">//remove 删除元素</span></span><br><span class="line">Sites.remove(<span class="string">&quot;yy&quot;</span>);</span><br><span class="line"><span class="comment">//getOrDefault() 查询元素，若无则返回指定的默认元素</span></span><br><span class="line">String value1=Sites.getOrDefault(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;sorry no found&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算哈希表大小</span></span><br><span class="line">xxxxx(Sites.size());<span class="comment">//2</span></span><br><span class="line"><span class="comment">//获取哈希表中所有value(返回一个数组)</span></span><br><span class="line">Sites.values()</span><br><span class="line"><span class="comment">//获取哈希表中所有的key(返回一个数组)</span></span><br><span class="line">Sites.keySet()</span><br><span class="line"><span class="comment">// 	检查 hashMap 中是否存在指定的 key 对应的映射关系  return bool</span></span><br><span class="line">Sites.containsKey(xx)</span><br><span class="line"><span class="comment">//检查 hashMap 中是否存在指定的 value 对应的映射关系。</span></span><br><span class="line">Sites.containsValue(xx)     </span><br></pre></td></tr></table></figure>

<h3 id="📌关于HashMap中的key类型："><a href="#📌关于HashMap中的key类型：" class="headerlink" title="📌关于HashMap中的key类型："></a>📌关于HashMap中的key类型：</h3><p>—————-🍃🍃🍃 为什么String 可以作为键类型，而一些引用类型如char数组等则不能？</p>
<p>hash算法（散列算法）：根据元素的hashCode值确定元素的存储位置，从而快速定位元素。由于元素的hashCode值一般不会连续，所以元素的存储位置一般也不会连续，即随机存储。</p>
<p>而HashMap的内部实现是通过key的hashCode来确定value的存储位置，key相同，value也应该相同。</p>
<p>首先String是不可变的，并且重写了hashCode()，<strong>所以即使两个字符串对象的引用不同，但只要值相同，它们的hashCode就相同</strong>，即可以得到相同的value。同时每当创建一个字符串对象的时候，它的hashCode就会被缓存下来，所以在HashMap中存储时避免了重新计算hashCode。</p>
<p>在《Java 编程思想》中有这么一句话：设计 hashCode() 时最重要的因素就是对同一个对象调用 hashCode() 都应该产生相同的值。String 类型的对象对这个条件有着很好的支持，<strong>因为 String 对象的 hashCode() 值是根据 String 对象的内容计算的，并不是根据对象的地址计算。</strong></p>
<p>来自String.java类源码：</p>
<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221011120803391.png" alt="image-20221011120803391" style="zoom:80%;" />

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221011120534200.png" alt="image-20221011120534200" style="zoom:80%;" />

<p>如果使用没有重写hashCode()的对象作为key，只要两个对象的引用不同，它们的hashCode就不同，所以想要检索出相同的value，就必须使用该value存储时使用的key对象。<strong>所以非 String 类型的数据类型在判断 key 相同时所需要的条件太过苛刻。我们一般会转换为String类型用作键</strong></p>
<p>如果你想把自定义的对象作为 key，只需要重写 hashCode() 方法与 equals() 方法即可，但依然无法像使用String作为key时对字符串对象的hashCode进行一个缓存。</p>
<p>❓一个使用char数组作为key 的测试：</p>
<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20221011121014617.png" alt="image-20221011121014617" style="zoom:80%;" />

<p>我们发现首先两个数组的hashcode是不同的，但Arrays.hashCode()方法确实实现了哈希码只与数组内容有关与地址无关，只是因为这里的carr1.hashCode默认调用的是Object中的hashCode，<strong>换言之carr1继承自Object,而Arrays只是个静态方法库，数组与之没有关系</strong></p>
<h2 id="HashSet（哈希集）"><a href="#HashSet（哈希集）" class="headerlink" title="HashSet（哈希集）"></a>HashSet（哈希集）</h2><p><strong>本质：一个没有重复元素的集合</strong>（并不是数组）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line">HashSet&lt;String&gt; sites=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">sites.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">sites.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">sites.add(<span class="string">&quot;a&quot;</span>)<span class="comment">//重复的元素将不再被添加</span></span><br><span class="line">System.out.println(sites); <span class="comment">//[a,b]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判段相关元素是否存在</span></span><br><span class="line">xxx(sites.contains(<span class="string">&quot;a&quot;</span>));  <span class="comment">//true</span></span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">sites.move(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">//计算元素个数</span></span><br><span class="line">sites.size();</span><br><span class="line"><span class="comment">//也可以使用增强for循环迭代</span></span><br></pre></td></tr></table></figure>

<h2 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h2><blockquote>
<p>本质：基于数组实现的列表，没有固定的大小限制，可以添加或删除元素</p>
</blockquote>
<h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList; <span class="comment">//引入</span></span><br><span class="line">ArrayList&lt;E&gt; xxx=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br></pre></td></tr></table></figure>

<blockquote>
<p>ArrayList中的元素都是对象，所以E只能为引用数据类型，当然目前我对这些名词也不是非常了解，总之需要用包装类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line">ArrayList&lt;String&gt;sites=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">//注意索引从0开始</span></span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">sites.add(<span class="string">&quot;cirs&quot;</span>);</span><br><span class="line">sites.add(<span class="string">&quot;william&quot;</span>);</span><br><span class="line"><span class="comment">//访问元素</span></span><br><span class="line">xxx(sites.get(<span class="number">1</span>)) ;  <span class="comment">//william</span></span><br><span class="line"><span class="comment">//修改元素</span></span><br><span class="line">sites.set(<span class="number">1</span>,<span class="string">&quot;jackson&quot;</span>); <span class="comment">//将William更改为jackson</span></span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">sites.remove(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//计算大小</span></span><br><span class="line">sites.size();</span><br><span class="line"><span class="comment">//排序 sort()方法</span></span><br><span class="line">sites.sort(xxx); <span class="comment">//参数为顺序方式</span></span><br><span class="line"><span class="comment">// 在此，Java Comparator 接口的 naturalOrder() 方法指定元素以自然顺序（升序）排序Comparator 接口还提供了对元素进行降序排列的方法：使用前记得引入</span></span><br><span class="line">sites.sort(Comparator.naturalOrder()); </span><br><span class="line">sites.sort(Comparator.reverseOrder());</span><br><span class="line"><span class="comment">//其他方式实现升序</span></span><br><span class="line">sites.sort((a,b)-&gt;a-b);</span><br></pre></td></tr></table></figure>

<h3 id="头插和尾插"><a href="#头插和尾插" class="headerlink" title="头插和尾插"></a>头插和尾插</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头插：add(0,ele)</span></span><br><span class="line">sites.add(<span class="number">0</span>,<span class="number">2</span>) <span class="comment">//即在头部插入了元素2</span></span><br><span class="line">sites.add(<span class="number">3</span>) <span class="comment">//尾插，在尾部插入元素3</span></span><br></pre></td></tr></table></figure>

<h3 id="易错讲解：泛类、引用传递、列表的复制"><a href="#易错讲解：泛类、引用传递、列表的复制" class="headerlink" title="易错讲解：泛类、引用传递、列表的复制"></a>易错讲解：泛类、引用传递、列表的复制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; test=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<span class="comment">//讲解点1</span></span><br><span class="line">ArrayList&lt;Integer&gt; inner=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">inner.add(<span class="number">1</span>);</span><br><span class="line">inner.add(<span class="number">2</span>);</span><br><span class="line">inner.add(<span class="number">3</span>);</span><br><span class="line">test.add(inner); </span><br><span class="line"><span class="comment">//注意这一步里往列表（其实就是容器）添加了一个列表对象，其存储的实际是对象的地址，所以后续一旦该inner对象变化，test也会相应变化，一言蔽之：这里的add是引用传递而不是值传递</span></span><br><span class="line">ArrayList&lt;Integer&gt; innerCopy=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(inner); <span class="comment">//拷贝inner,都是基本数据类型，故都拷贝值</span></span><br><span class="line">test.add(innerCopy);</span><br><span class="line">System.out.println(test); <span class="comment">//[[1, 2, 3], [1, 2, 3]]</span></span><br><span class="line">System.out.println(inner);<span class="comment">//[1, 2, 3]</span></span><br><span class="line">System.out.println(innerCopy);</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; testCopy=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;(test); <span class="comment">//拷贝test，内部是两个对象，故是浅拷贝/引用拷贝</span></span><br><span class="line">System.out.println(testCopy);</span><br><span class="line">inner.set(<span class="number">0</span>, <span class="number">666</span>); <span class="comment">//inner变化 test也会变</span></span><br><span class="line">System.out.println(test);<span class="comment">//[[666, 2, 3], [1, 2, 3]]</span></span><br><span class="line">System.out.println(inner);<span class="comment">//[666, 2, 3]</span></span><br><span class="line">System.out.println(innerCopy);<span class="comment">//[1, 2, 3]</span></span><br><span class="line">System.out.println(testCopy);<span class="comment">//[[666, 2, 3], [1, 2, 3]]</span></span><br></pre></td></tr></table></figure>

<p>讲解1：泛型的🕳</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; test=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ArrayList&lt;Integer&gt;&gt;(); </span><br><span class="line"><span class="comment">//error:：ArrayList&lt;ArrayList&lt;&gt;&gt;can&#x27;t convert to List&lt;List&lt;&gt;&gt; 类型转换错误</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;&gt;=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;() <span class="comment">//正确✔</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*原因： ArrayList继承自List所以可以直接复制，上述是正确的</span></span><br><span class="line"><span class="comment">但 Box&lt;ArrayList&lt;&gt;&gt; 并不是 Box&lt;List&lt;&gt;&gt;的子类型，他们是并列的*/</span></span><br><span class="line">同理pg:Integer 是 Number 的子类，Double 也是 Number 的子类， 但是，Box&lt;Integer&gt; 和 Box&lt;Double&gt; 都不是 Box&lt;Number&gt; 的子类，它们的关系是并列的，都是 Object 的子类。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>讲解3：ArrayList的复制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以通过new ArrayList&lt;&gt;(source) 的方式复制list</span></span><br><span class="line">ArrayList&lt;Integer&gt; innerCopy=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(inner);</span><br><span class="line"><span class="comment">/*原理：</span></span><br><span class="line"><span class="comment">将源list重新拷贝一份放在堆的另一处（新地址），在栈区用新的引用变量（innerCopy）指向它，innerCopy值就是其在堆中的新地址</span></span><br><span class="line"><span class="comment">inner: 889895---&gt;[1,2,3]</span></span><br><span class="line"><span class="comment">innerCopy:123568---&gt;[1,2,3]</span></span><br><span class="line"><span class="comment">关于上述的“拷贝”说明：对于基本数据类型是深拷贝，对于引用类型/对象是浅拷贝。</span></span><br><span class="line"><span class="comment">比如上面我修改了inner后，innerCopy仍然是123，当时拷贝的就是个值，改变inner不会影响innerCopy</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//如上面我也拷贝了test</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; testCopy=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;(test); <span class="comment">//拷贝test，内部是两个对象，故是浅拷贝/引用拷贝</span></span><br><span class="line">System.out.println(testCopy);<span class="comment">//[[666, 2, 3], [1, 2, 3]]</span></span><br><span class="line"><span class="comment">//改变inner,testCopy也会改变，因为其内部装的是inner的地址。</span></span><br></pre></td></tr></table></figure>

<p>注意数组的复制：就是下面6的那两种，复制原理均与此相同</p>
<h2 id="LinkedList-链接列表"><a href="#LinkedList-链接列表" class="headerlink" title="LinkedList 链接列表"></a>LinkedList 链接列表</h2><blockquote>
<p>本质：基于链表实现的列表，相较于ArrayList优势在于插入，而非查询（因为需要遍历整个链表，时间复杂度UP）</p>
<p>但因为ArrayList涉及数组扩容问题，</p>
<p>LinkedList还可以作为双端队列使用，其实现了Deque接口，具有队列，栈，列表三者性质</p>
</blockquote>
<h2 id="ArrayDeque-数组双端队列"><a href="#ArrayDeque-数组双端队列" class="headerlink" title="ArrayDeque 数组双端队列"></a>ArrayDeque 数组双端队列</h2><blockquote>
<p>侧重于双端队列上，数组的特性倒是没有体现太多。<br>不支持使用get索引查找</p>
<p>双端队列Deque：☞支持在两端插入、删除<br>本质：具有栈&amp;队列的双重特性</p>
<p>【摘录】：此类很可能在用作堆栈时快于 <a href="../../java/util/Stack.html"><code>Stack</code></a>，在用作队列时ad快于 <a href="../../java/util/LinkedList.html"><code>LinkedList</code></a>。</p>
</blockquote>
<h3 id="一些操作"><a href="#一些操作" class="headerlink" title="一些操作"></a>一些操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ArrayDeque&lt;Integer&gt; deq=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">deq.offerFirst(<span class="number">1</span>)<span class="comment">//头部插入</span></span><br><span class="line">deq.offerLast(<span class="number">2</span>) p<span class="comment">//尾部插入</span></span><br><span class="line">deq.pollFirst() <span class="comment">//移除开头 1</span></span><br><span class="line">deq.pollLast() <span class="comment">//移除结尾 2</span></span><br><span class="line">deq.peekFirst() <span class="comment">//获取开头，不移除</span></span><br><span class="line">deq.peekLast() <span class="comment">//获取结尾，不移除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//双端队列转List</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(deq)</span><br><span class="line"><span class="comment">//-------以前----------------------</span></span><br><span class="line"><span class="comment">//栈中所有方法</span></span><br><span class="line">deq.push(<span class="number">1</span>); </span><br><span class="line">dep.push(<span class="number">2</span>); </span><br><span class="line"><span class="type">int</span> b=deq.pop();</span><br><span class="line"><span class="type">int</span> c=deq.peek();</span><br><span class="line"><span class="comment">//queue队列方法</span></span><br><span class="line">deq.add(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> a=deq.poll();<span class="comment">//获取并移除队列头</span></span><br><span class="line"><span class="type">int</span> a1=deq.peek();<span class="comment">//获取但不移除队列的头</span></span><br></pre></td></tr></table></figure>

<p>一个怪事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayDeque&lt;Integer&gt; test=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">test.push(<span class="number">2</span>);</span><br><span class="line">test.push(<span class="number">1</span>);</span><br><span class="line">System.out.println(test); <span class="comment">//[2,1]</span></span><br><span class="line">Stack&lt;Integer&gt; s=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">s.push(<span class="number">1</span>);</span><br><span class="line">s.push(<span class="number">2</span>); </span><br><span class="line">System.out.println(s); <span class="comment">//[1,2]</span></span><br></pre></td></tr></table></figure>



<h2 id="🌈-PrintStream-类"><a href="#🌈-PrintStream-类" class="headerlink" title="🌈: PrintStream 类"></a>🌈: PrintStream 类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(); </span><br><span class="line"><span class="comment">/*本质上是使用到了PrintStream类中的println方法*/</span></span><br><span class="line"><span class="comment">//1.out的本质</span></span><br><span class="line">out实际上是System类中的静态变量/静态字段,具体声明:</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PrintStream out</span><br><span class="line"><span class="comment">//2.关于println()方法的功能</span></span><br><span class="line"><span class="comment">//打印一些基本的数据类型</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">boolean</span> x)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">char</span> x)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">long</span> x)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">float</span> x)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line"><span class="comment">//对象方面</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">char</span>[] x)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String x)</span></span><br><span class="line">        -----------示例--------------------------------------------------------------</span><br><span class="line"><span class="type">char</span>[] test= &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">System.out.println(test); <span class="comment">//可以直接打印char[] 的数组内容 </span></span><br><span class="line">String aString=<span class="string">&quot;has&quot;</span>;</span><br><span class="line">System.out.println(aString); <span class="comment">//可直接打印String字符串变量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(Object x)</span></span><br><span class="line">此方法本质是调用 String.valueOf(x) 获取打印对象的字符串值，然后的行为如同先调用 print(String) 再调用 println() 一样。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="🍃Expolored-—String-valueOf-c"><a href="#🍃Expolored-—String-valueOf-c" class="headerlink" title="🍃Expolored  —String.valueOf(c)"></a>🍃Expolored  —String.valueOf(c)</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># c可为：int float double long boolean char  char[]  </span></span><br><span class="line">返回其字符串形式</span><br><span class="line"></span><br><span class="line"><span class="section"># valueOf(char[] data, int offset, int count)</span></span><br><span class="line">支持返回char数组特定的子数组的字符串表示形式</span><br><span class="line">所以char数组转字符串，请使用String.valueOf方法而不是toString方法</span><br><span class="line"></span><br><span class="line"><span class="section">## public static String valueOf(Object obj)返回 Object 参数的字符串表示形式。 </span></span><br><span class="line">参数：</span><br><span class="line">obj - 一个 Object。 </span><br><span class="line">返回：</span><br><span class="line">如果参数为 null，则字符串等于 &quot;null&quot;；否则，返回 obj.toString() 的值。</span><br><span class="line"><span class="section"># 本质：Object.toString()</span></span><br></pre></td></tr></table></figure>

<h2 id="🍃-Expolored-—Object-toString"><a href="#🍃-Expolored-—Object-toString" class="headerlink" title="🍃: Expolored  —Object.toString()"></a>🍃: Expolored  —Object.toString()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    </span><br><span class="line">返回该对象的字符串表示。通常，toString 方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。建议所有子类都重写此方法。 </span><br><span class="line">Object 类的 toString 方法返回一个字符串，该字符串由类名（对象是该类的一个实例）、at 标记符“@”和此对象哈希码的无符号十六进制表示组成。换句话说，该方法返回一个字符串，它的值等于： </span><br><span class="line">    </span><br><span class="line">getClass().getName() + <span class="string">&#x27;@&#x27;</span> + Integer.toHexString(hashCode())</span><br><span class="line">返回：</span><br><span class="line">该对象的字符串表示形式。</span><br></pre></td></tr></table></figure>

<p><strong>AbstractCollection抽象类中重写了toString方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">返回此 collection 的字符串表示形式。该字符串表示形式由 collection 元素的列表组成，这些元素按其迭代器返回的顺序排列，并用方括号 (<span class="string">&quot;[]&quot;</span>) 括起来。相邻元素由字符 <span class="string">&quot;, &quot;</span>（逗号加空格）分隔。通过 String.valueOf(Object) 可以将元素转换成字符串。 </span><br><span class="line"></span><br><span class="line">覆盖：</span><br><span class="line">类 Object 中的 toString</span><br><span class="line">返回：</span><br><span class="line">此 collection 的字符串表示形式</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>AbstractCollection抽象类直接已知子类</strong></p>
<ul>
<li><p><strong>已知子类：</strong></p>
<p>AbstractList  </p>
<ul>
<li>AbstractSequentialList<ul>
<li>LinkedList</li>
</ul>
</li>
<li>ArrayList</li>
<li>Vector</li>
</ul>
<p> AbstractQueue   </p>
<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220908162143695.png" alt="image-20220908162143695" style="zoom:80%;" />

<p>AbstractSet</p>
<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220908162207119.png" alt="image-20220908162207119" style="zoom:80%;" />

<p>ArrayDeque</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码：</span></span><br><span class="line">ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">String str=list.toString(); <span class="comment">//[1, 2, 3]</span></span><br><span class="line">System.out.println(list);<span class="comment">//[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">ArrayDeque&lt;Integer&gt; deque=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">deque.push(<span class="number">1</span>);</span><br><span class="line">System.out.println(deque);<span class="comment">//[1]</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] intTest= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>&#125;;</span><br><span class="line">System.out.println(intTest);<span class="comment">//[I@7852e922  </span></span><br><span class="line">System.out.println(intTest.toString());</span><br><span class="line">String[] strTest= &#123;<span class="string">&quot;hhh&quot;</span>,<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;kkk&quot;</span>&#125;;</span><br><span class="line">System.out.println(strTest); <span class="comment">//[Ljava.lang.String;@4e25154f </span></span><br></pre></td></tr></table></figure>

<h2 id="🌈-int-转-String的三种方法"><a href="#🌈-int-转-String的三种方法" class="headerlink" title="🌈: int 转 String的三种方法"></a>🌈: int 转 String的三种方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String.valueOf(<span class="type">int</span> i)</span><br><span class="line">Integer.toString(<span class="type">int</span> i)</span><br><span class="line">i + <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">//三种方法效率排序为：</span></span><br><span class="line">Integer.toString(<span class="type">int</span> i) &gt; String.valueOf(<span class="type">int</span> i) &gt; i+<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="🌈-’a’转到-‘b’"><a href="#🌈-’a’转到-‘b’" class="headerlink" title="🌈:’a’转到 ‘b’"></a>🌈:’a’转到 ‘b’</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>) <span class="comment">//33 结果为int类型</span></span><br><span class="line"><span class="comment">//字符加一个int数都是int类型，而字符串加int则转换为String</span></span><br><span class="line"><span class="comment">//故只能强转</span></span><br><span class="line">System.out.println((<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>)) <span class="comment">//b</span></span><br></pre></td></tr></table></figure>

<h2 id="🌈-int整数与数组的互转—-char数组"><a href="#🌈-int整数与数组的互转—-char数组" class="headerlink" title="🌈: int整数与数组的互转—&gt;char数组"></a>🌈: int整数与数组的互转—&gt;char数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> data=<span class="number">8935</span>;</span><br><span class="line"><span class="type">char</span>[] res=String.valueOf(data).toCharArray();</span><br><span class="line"><span class="comment">//数组转int整数</span></span><br><span class="line"><span class="type">int</span> cData=Integer.parseInt(<span class="keyword">new</span> <span class="title class_">String</span>(res));</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//遍历数组值    该方法通过定义一个变量（如num）装载当前遍历到的数组值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;当前遍历到的数字是&quot;</span>+num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//keySet() 方法可以与 for-each 循环一起使用，用来遍历迭代 HashMap 中的所有键。4</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> key:sites.keySet())&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;key:&quot;</span>+key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<h1 id="2021前置知识"><a href="#2021前置知识" class="headerlink" title="2021前置知识"></a>2021前置知识</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1-初始化方式"><a href="#1-初始化方式" class="headerlink" title="1.初始化方式"></a>1.初始化方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态：立即赋值</span></span><br><span class="line"><span class="type">int</span>[] arr;<span class="comment">//声明</span></span><br><span class="line">arr=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">//先声明再初始化（赋值）</span></span><br><span class="line"><span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//声明时赋值(支持简写)</span></span><br><span class="line"><span class="comment">/*简写*/</span> <span class="type">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;  </span><br><span class="line"><span class="comment">//动态：系统分配初始值</span></span><br><span class="line"><span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];  <span class="comment">//数组长度为3 默认值为0</span></span><br></pre></td></tr></table></figure>

<p>关于 int[] 我的理解：</p>
<p>类似js 中，可以把int[]看成数组字面量，和Array类似，是一种数组标识，故可以理解为何静态初始化时  []  中不能加数字。</p>
<blockquote>
<p>上述的Array初始化时都需要指定固定的大小，使用ArrayList类则可以突破这一限制，可以理解为一个数组队列，可以任意添加，删除，寻找，甚至排序元素（见上方）</p>
</blockquote>
<h3 id="2-内存原理"><a href="#2-内存原理" class="headerlink" title="2.内存原理"></a>2.内存原理</h3><p><em>数组变量</em>（数组名）存储<em>数组对象的首地址</em>，被储存在栈中，初始化后，数组对象被存储在堆中连续的存储空间。一旦初始化完成，内存分配即结束，后续再无法改变数组的长度。</p>
<h3 id="3-二维数组"><a href="#3-二维数组" class="headerlink" title="3.二维数组"></a>3.二维数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态初始化</span></span><br><span class="line"><span class="type">int</span>[][] arr=<span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;</span><br><span class="line">    &#123;<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">&#125;;<span class="comment">//类似的也可以简写、也可以先声明再写</span></span><br><span class="line"><span class="comment">//动态</span></span><br><span class="line"><span class="type">int</span>[][] arr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>]; <span class="comment">//动态初始化3*4列的数组</span></span><br><span class="line"><span class="comment">//ps:对于一个二维数组，二维数组的长度就是其行的数目，即3</span></span><br></pre></td></tr></table></figure>

<h3 id="4-特殊的二维数组—锯齿形-三角状"><a href="#4-特殊的二维数组—锯齿形-三角状" class="headerlink" title="4.特殊的二维数组—锯齿形(三角状)"></a>4.特殊的二维数组—锯齿形(三角状)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态初始化锯齿行数组</span></span><br><span class="line"><span class="type">int</span>[][] arr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>][];<span class="comment">//只指定第一个下标</span></span><br><span class="line">arr[<span class="number">0</span>]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">arr[<span class="number">1</span>]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">arr[<span class="number">2</span>]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">3</span>]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">arr[<span class="number">4</span>]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<h3 id="5-补充：打印数组的方式"><a href="#5-补充：打印数组的方式" class="headerlink" title="5.补充：打印数组的方式"></a>5.补充：打印数组的方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] arr= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(arr));  <span class="comment">//打印数组  [1,2,3]</span></span><br><span class="line"><span class="comment">//ps：Arrays.toString（）方法内核是创建了一个StringBuilder，依次添加‘[’ &#x27;1&#x27;  &#x27;2&#x27;  &#x27;3&#x27;  ],最后用toString转换为String类型，返回一个字符串</span></span><br></pre></td></tr></table></figure>

<h3 id="6-补充：复制数组的方式（Arrays-copyOf）-System-arraycopy"><a href="#6-补充：复制数组的方式（Arrays-copyOf）-System-arraycopy" class="headerlink" title="6.补充：复制数组的方式（Arrays.copyOf）(System.arraycopy)"></a>6.补充：复制数组的方式（Arrays.copyOf）(System.arraycopy)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.Arrays静态类库方法 这里以复制int数组为例</span></span><br><span class="line">Arrays.copyOf(<span class="type">int</span>[] original,<span class="type">int</span> newLength);  <span class="comment">//newLength为新数组长度，原数组不足：补0，超过则截取[0-newlength)</span></span><br><span class="line">Arrays.copyOfRange(<span class="type">int</span>[] original,<span class="type">int</span> from,<span class="type">int</span> to) <span class="comment">//仅使用（复制）原数组的[from,to)部分</span></span><br><span class="line">    <span class="comment">//本质：通过复制的方式构建一个新数组，返回一个新数组</span></span><br><span class="line"><span class="comment">//2.System静态库方法</span></span><br><span class="line">    <span class="comment">//本质：返回void,功能是：将原数组的一部分复制到另数组中</span></span><br><span class="line">    <span class="comment">//srcPos；原数组起始复制位，destPos：目标数组粘贴起始位，length：复制长度</span></span><br><span class="line">System.arraycopy(<span class="type">int</span>[] src,<span class="type">int</span> srcPos,<span class="type">int</span>[] dest,<span class="type">int</span> destPos,<span class="type">int</span> length);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意2方法效率是最高的，详情可以看</p>
<p>[四种拷贝方法与效率解析]: <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34834846/article/details/97174521?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166212386916782395380275%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=166212386916782395380275&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_v39-10-97174521-null-null.142%5Ev46%5Epc_rank_34_2&amp;utm_term=arrays.copyof%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/qq_34834846/article/details/97174521?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166212386916782395380275%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=166212386916782395380275&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_v39-10-97174521-null-null.142^v46^pc_rank_34_2&amp;utm_term=arrays.copyof%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D&amp;spm=1018.2226.3001.4187</a>	“四种拷贝方法与效率解析”</p>
<h3 id="7-数组排序（Arrays-sort-）"><a href="#7-数组排序（Arrays-sort-）" class="headerlink" title="7.数组排序（Arrays.sort()）"></a>7.数组排序（Arrays.sort()）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="type">int</span>[] arr=&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Arrays.sort(arr)  <span class="comment">//arr:1,2,3,4 默认是升序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//若希望进行降序排列，或其他更复杂的情况，需要用到自定义排序</span></span><br><span class="line">Integer[] test=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>&#125;;</span><br><span class="line">Arrays.sort(test,(a,b)-&gt;&#123;<span class="keyword">return</span> b-a;&#125;);</span><br><span class="line"><span class="keyword">for</span>(Integer t:test)&#123;</span><br><span class="line">     System.out.println(t);<span class="comment">//3,2,1,0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只有对象数组才能使用自定义比较器排序</span></span><br></pre></td></tr></table></figure>

<p>![image-20230613114052739](&#x2F;Users&#x2F;hxyh&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230613114052739.png)</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><blockquote>
<p>补充：注意：java中，函数的形参必须是完整的参数类型，加参数名，即 int num1, 不能只写参数类型：int</p>
</blockquote>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>理解角度：就是函数，部分代码封装起来，以供程序反复调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义的语法格式</span></span><br><span class="line"><span class="comment">/*例子*/</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hanshuming</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    XXXXX</span><br><span class="line">&#125;<span class="comment">//修饰符 返回值类型 方法名称 （形参列表）</span></span><br></pre></td></tr></table></figure>

<h3 id="2-方法调用的内存原理"><a href="#2-方法调用的内存原理" class="headerlink" title="2.方法调用的内存原理"></a>2.方法调用的内存原理</h3><p>每调用一个方法，jvm创建一个新的栈帧，用于保存传入形参和局部变量的值，该方法操作的都是该栈帧中的值。待调用结束，释放对应栈帧。</p>
<p>可见：实参和形参的存储单元不同</p>
<h3 id="3-方法重载"><a href="#3-方法重载" class="headerlink" title="3.方法重载"></a>3.方法重载</h3><p>重载概念：方法名称相同，形参列表不同的方法（即参数类型，顺序，数目，任意一个不同即可），对返回值不做要求。在调用方法时，编译器会寻找最准确的方法进行调用。</p>
<h3 id="4-数组的引用传递"><a href="#4-数组的引用传递" class="headerlink" title="4.数组的引用传递"></a>4.数组的引用传递</h3><p>向方法传递数组时，传递的是数组名，相当于把地址值赋给了栈中的另一个变量pa,  pa指向堆中的数组对象，可以对其进行操纵，对栈中的局部变量newarr进行初始化，newarr的数组对象被存在堆区，方法执行完毕，局部变量pa、newarr都将被释放,但newarr值被传递出去，给了copy，copy指向那片堆区</p>
<p>我认为ps:方法调用完毕，释放的是栈中的变量，即栈中保存的地址，而其指向的数组对象在堆区。故不会消失，copy得到地址后，还可以指向</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] copy=rev(array);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rev</span><span class="params">(<span class="type">int</span>[] pa)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] newarr=<span class="keyword">new</span> <span class="title class_">int</span>[pa.length];</span><br><span class="line">    <span class="comment">/*复制值的过程 xxxxxxx*/</span></span><br><span class="line">    <span class="keyword">return</span> newarr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="1-类与对象"><a href="#1-类与对象" class="headerlink" title="1.类与对象"></a>1.类与对象</h3><p>类是封装对象行为和属性的载体，对象是类抽象出来的实例。</p>
<p>类的特性：封装（隐藏类的细节，增加安全性），继承，多态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;       <span class="comment">//类名大写！！</span></span><br><span class="line">    String name;    <span class="comment">//声明属性</span></span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;        <span class="comment">//定义方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象的创建</span></span><br><span class="line">Person wang=<span class="keyword">new</span> <span class="title class_">Person</span>();<span class="comment">//对象名是一个引用变量，类似数组变量。利用new实例化一个对象后，将返回对象的引用 ，并赋给wang，wang存在于栈中，指向堆中的对象。当某对象不再被任何变量引用时（即没有变量存其地址），该对象变为垃圾，等待回收。</span></span><br><span class="line"><span class="comment">//new创建对象时，会为每个对象开辟独立的堆空间，保存成员变量的值，且会*****自动为成员变量赋默认值。！！！****</span></span><br></pre></td></tr></table></figure>

<h3 id="2-访问控制符"><a href="#2-访问控制符" class="headerlink" title="2.访问控制符"></a>2.访问控制符</h3><p>控制使用权限的关键字，在类、成员变量、方法前均可以添加。</p>
<p>有：public  、    private   、  protected   、 默认（即不加）</p>
<ul>
<li>public :<strong>均可以</strong>访问，对于<strong>其他包</strong>类的访问，需要导入相关Public类所在的包</li>
<li>protected:<strong>同一包中</strong>、<strong>其他包的子类</strong>均可访问，其他包中的非子类不能访问</li>
<li>默认：包访问性，<strong>同一包</strong>才能访问，与是否是子类无关</li>
<li>private:最高级别保护，只有在<strong>当前类</strong>中才能访问</li>
</ul>
<h3 id="3-构造方法"><a href="#3-构造方法" class="headerlink" title="3.构造方法"></a>3.构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//new 关键字创建对象时被调用，用于为类中属性初始化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;                  <span class="comment">//方法名与类名相同 且 没有返回值类型！！！</span></span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法自动被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果在类中未定义任何构造方法，系统自动默认提供一个。若已经有，则不再提供</span></span><br><span class="line"><span class="comment">//常见错误:你自己定义了一个有参构造，下面又 Person p=new Person();会因找不到相应的无参构造而报错。</span></span><br><span class="line"><span class="comment">//构造方法是可以重载的，根据需要设置参数。为避免上述错误，在定义类的构造方法时，应预先定义一个无参的构造方法。</span></span><br></pre></td></tr></table></figure>

<h3 id="4-this-关键字"><a href="#4-this-关键字" class="headerlink" title="4.this 关键字"></a>4.this 关键字</h3><p>this就是当前调用对象本身。一般在类中使用，通过this可以调用类中的属性、方法。</p>
<p>特别的，在构造函数中 通过 this(形参列表) 可以调用相应形参列表的其他构造函数！但只能掉一次，且位于首行</p>
<h3 id="5-垃圾回收"><a href="#5-垃圾回收" class="headerlink" title="5.垃圾回收"></a>5.垃圾回收</h3><p>使用new 创建数组、对象等引用类型，都将在堆中为其分配一块内存保存对象，当某对象不再被任何变量引用时（即没有变量存其地址），该对象变为垃圾，等待回收。JVM会自动清理被占用的 内存，无需显示释放（与C不同）</p>
<h3 id="6-static关键字"><a href="#6-static关键字" class="headerlink" title="6.static关键字"></a>6.static关键字</h3><p>static表示静态的，用于修饰成员变量，成员方法，以及代码块。不能修饰成员方法中的局部变量！！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态变量</span></span><br><span class="line"><span class="comment">//static修饰的成员变量称为静态变量或类变量，被类的所有对象共享，为类所有，故可以用类名直接访问，无需创建对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStatic</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(Person.age);<span class="comment">//该内存中只有一份age,不管创建多少个对象，age都是同一个</span></span><br><span class="line">        Person p=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        System.out.println(p.name);<span class="comment">//未使用static 修饰的成员变量，称为实例变量，未具体对象所有，必须通过引用变量调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line"><span class="comment">//为类所有，故可以用类名直接访问，无需创建对象 ，但静态方法只能使用静态成员不能使用实例成员</span></span><br><span class="line"><span class="comment">//由于main方法固定声明为静态方法，所以想要在main方法中使用的方法必须声明为静态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(age); <span class="comment">//正确</span></span><br><span class="line">        System.out.println(name); <span class="comment">//错误  实例变量必须在对象开辟内存后才能使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-内部类"><a href="#7-内部类" class="headerlink" title="7.内部类"></a>7.内部类</h3><p>内部类与外部类，经编译后生成的两个类是独立的；</p>
<p>内部类是外部类的成员，内部类可以直接访问外部类的所有成员，而外部类想访问内部类，则需要创建内部类对象。</p>
<p>内部类可以为静态，可以用protected、private修饰，而外部类，只能用public 和默认显示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成员内部类</span></span><br><span class="line"><span class="comment">//外部类外创建内部类对象语法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">&quot;waibu&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;   <span class="comment">//定义内部类成员</span></span><br><span class="line">        <span class="keyword">private</span> String name=<span class="string">&quot;neibu&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(Other.<span class="built_in">this</span>.name); <span class="comment">//外部类名.this  表示外部类对象  waibu</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name);<span class="comment">//neibu</span></span><br><span class="line">            System.out.println(age);  <span class="comment">//不重名的情况下可以直接访问</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInner</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//在外部创建一个内部类对象</span></span><br><span class="line">        Other.Inner obj=<span class="keyword">new</span> <span class="title class_">Other</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        obj.say();<span class="comment">//waibu  neibu 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name=<span class="string">&quot;waibu&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;   <span class="comment">//定义静态内部类成员</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> String name=<span class="string">&quot;neibu&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(Other.name); <span class="comment">//  表示外部类静态对象  waibu</span></span><br><span class="line">            System.out.println(name);<span class="comment">//neibu</span></span><br><span class="line">            System.out.println(age);  <span class="comment">//不重名的情况下可以直接访问</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInner</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        String str=Other.Inner.name;  <span class="comment">//访问静态内部类的静态成员 </span></span><br><span class="line">        <span class="comment">//在外部创建一个静态内部类对象</span></span><br><span class="line">        Other.Inner obj=<span class="keyword">new</span> <span class="title class_">Other</span>.Inner(); <span class="comment">//因为静态成员可以直接用类名调用，无需创建对象</span></span><br><span class="line">        obj.say();<span class="comment">//waibu  neibu 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态成员的访问无需创建对象，直接用类名调用，但实例对象就要创建，对象调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法内部类</span></span><br><span class="line"><span class="comment">//即在成员方法中定义的类，与局部变量类似，作用域仅在当前方法中，只能在方法中对其进行实例化。</span></span><br></pre></td></tr></table></figure>

<h3 id="📅-8-intance-of-关键字"><a href="#📅-8-intance-of-关键字" class="headerlink" title="📅: 8.intance of 关键字"></a>📅: 8.intance of 关键字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> res=(object) instance of xxx;</span><br><span class="line"><span class="comment">//判段某对象是否是 一个类的实例对象、一个接口的实现类的实例对象、一个父类的子类的实例对象</span></span><br><span class="line">关键：只能用于判段对象类型，不能用于基本类型的判段</span><br><span class="line">    如 <span class="type">int</span> a=<span class="number">5</span>;a instance of Integer ❌</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"> 	System.out.println(integer <span class="keyword">instanceof</span>  Integer);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其他应用场景：在强转之前用它来判断是否可以强制转换：</span></span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">instanceof</span> B) &#123;</span><br><span class="line">        <span class="keyword">return</span> (B) a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





























<h4 id="面向对象（下）"><a href="#面向对象（下）" class="headerlink" title="面向对象（下）"></a>面向对象（下）</h4><h5 id="1-继承"><a href="#1-继承" class="headerlink" title="1.继承"></a>1.继承</h5><p>继承：即在已有类型上定义新的类，新的类继承原有类的属性与方法，并扩展新的功能。已有类称为父类&#x2F;基类，新的类称为子类&#x2F;派生类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承的语法格式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">parent</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">double</span> property;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BABA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> <span class="keyword">extends</span> <span class="title class_">parent</span>&#123;</span><br><span class="line">    <span class="type">int</span> age;          <span class="comment">//增加属性，扩展父类功能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;haizi&quot;</span>);  <span class="comment">//重写父类方法</span></span><br><span class="line">        <span class="built_in">super</span>.say();  <span class="comment">//&quot;BABA&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-重写父类方法的理解"><a href="#2-重写父类方法的理解" class="headerlink" title="2.重写父类方法的理解"></a>2.重写父类方法的理解</h5><ul>
<li><p>重写父类方法：即重新定义父类的成员方法，被子类重写的方法不能比原父类方法的权限更严格。</p>
</li>
<li><p>重写父类方法只能改变修饰符，类名，返回值，参数，都不能变。</p>
<blockquote>
<p>注意：参数不能变仅指参数类型&#x2F;个数不能变，但形参的参数名可以任意指定</p>
</blockquote>
</li>
<li><p>方法重写与方法重载的区别：方法重载是在一个类中，而重写是在不同类（父子类）</p>
</li>
</ul>
<h5 id="3-super关键字的使用"><a href="#3-super关键字的使用" class="headerlink" title="3.super关键字的使用"></a>3.super关键字的使用</h5><p>使用1：当父类方法被重写，子类对象将不能访问原方法，如果需要访问被重写的原方法，可以用super实现。</p>
<p>使用二：在实例化子类对象时，首先会调用父类的构造方法，在调用子类本身。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.利用super显式调用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;隐式调用默认调用无参的构造函数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    <span class="type">int</span> age;          <span class="comment">//增加属性，扩展父类功能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;haizi gei baba de &quot;</span>);  <span class="comment">//调用父类的有参构造</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.隐式调用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实例化对象时，先默认调用无参的构造函数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    <span class="type">int</span> age;          <span class="comment">//增加属性，扩展父类功能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;然后再输出自己的构造函数内容&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-final关键字的使用"><a href="#4-final关键字的使用" class="headerlink" title="4.final关键字的使用"></a>4.final关键字的使用</h5><ul>
<li>final关键字修饰类</li>
</ul>
<p>final关键字修饰的类为最终类，不能再被其他类继承</p>
<ul>
<li>final关键字修饰方法</li>
</ul>
<p>final关键字修饰的方法，不能再被其子类重写，故称之为最终方法。</p>
<ul>
<li><p>final关键字修饰变量</p>
<p>final关键字修饰的变量，称为<strong>常量</strong>，只能初始化（赋值）一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例1：final修饰局部变量</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> age=<span class="number">18</span>;  <span class="comment">//age不能再被修改</span></span><br><span class="line"><span class="comment">//2.final修饰成员变量</span></span><br><span class="line"><span class="comment">//java 虚拟机不会为final修饰的变量默认初始化，所以这里age未被初始化，不能使用！</span></span><br><span class="line"><span class="comment">//故被final修饰的成员变量，必须在声明时初始化：1.构造函数中赋值2.直接赋值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        system.out.println(age);  <span class="comment">//18</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用构造函数赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInner</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Parent p=<span class="keyword">new</span> <span class="title class_">Parent</span>(<span class="number">18</span>);</span><br><span class="line">    &#125;&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="5-抽象类与接口"><a href="#5-抽象类与接口" class="headerlink" title="5.抽象类与接口"></a>5.抽象类与接口</h5><h6 id="1-抽象类（abstract关键字）"><a href="#1-抽象类（abstract关键字）" class="headerlink" title="1.抽象类（abstract关键字）"></a>1.抽象类（abstract关键字）</h6><ul>
<li><p>抽象类、抽象方法：用abstract关键字修饰的类、方法。</p>
</li>
<li><p>抽象方法：<strong>只有方法的声明，没有方法体</strong>的方法称为抽象方法。该方法的方法体由子类根据实际需求实现。</p>
<p><strong>只要含一个抽象方法的类一定是抽象类。</strong>：抽象类也可以不含任何抽象方法。此时当作正常类用就行，只是不能被实例化。</p>
</li>
<li><p><strong>抽象类不能被实例化（new）</strong>,只能通过子类继承才实现，因为可能包含抽象方法，而抽象方法不能被调用。</p>
<p>由此得：抽象方法不能被final、static、private关键字修饰，（对于static：因为其修饰的方法能直接通过类名调用，而抽象方法不能被调用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    <span class="comment">//声明两个抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String s)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    <span class="comment">//实现抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        System.out.println(s);   <span class="comment">//实现抽象方法时，参数列表要相同</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽象类的子类必须实现父类所有的抽象方法，否则子类仍继承有抽象方法，故子类也必须声明为抽象类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;work is happy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="2-接口（interface关键字）"><a href="#2-接口（interface关键字）" class="headerlink" title="2.接口（interface关键字）"></a>2.接口（interface关键字）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态变量和公共抽象方法的集合，形式上类似于一个类</span></span><br><span class="line"><span class="comment">//接口中定义的变量、方法都隐含默认的修饰符</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    String name;    <span class="comment">//等价于 public static final String name;</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;     <span class="comment">//等价于 public abstract void say();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其功能与抽象类类似，都是用于为对象定义共同的行为，概述一个类的外围能力</span></span><br></pre></td></tr></table></figure>

<p><u>怎么来实现接口中的抽象方法呢？</u></p>
<p>我们需要用类来实现接口，用到关键字（<strong>implements</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码接上</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个类可以用于实现多个接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">implements</span> <span class="title class_">Person</span>,Parent&#123;</span><br><span class="line">    <span class="comment">//ps:在实现时一定要加public ，因为原方法的权限是public ，不能降低方法的可视性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现say()函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现work()方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口之间也是可以继承的，我认为没有很大意义，不过是先提前把接口都装到一个子接口中，然后实现时只用写一个罢了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">All</span> <span class="keyword">extends</span> <span class="title class_">Person</span>,Parent&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">all</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">GradedaoImplement gd=<span class="keyword">new</span> <span class="title class_">GradedaoImplement</span>();</span><br><span class="line">		SqlSession session=GetSqlSession.createSqlSession();</span><br><span class="line">		String courseName=req.getParameter(<span class="string">&quot;courseName&quot;</span>);</span><br><span class="line">		List&lt;Grade&gt; gradeList=gd.getGrade(courseName,session);</span><br><span class="line">		req.setAttribute(<span class="string">&quot;gl&quot;</span>, gradeList);</span><br><span class="line">		req.getRequestDispatcher(<span class="string">&quot;showGrade.jsp&quot;</span>);</span><br><span class="line"><span class="comment">//实现接口时，必须实现该接口继承的所有接口。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">implements</span> <span class="title class_">All</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">all</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现all()函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现say()函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现work()方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sum：由此我们看出，interface相比抽象类更加强大，因为其不论是  接口之间的继承、还是 类来实现接口 都可以有多个。</p>
<p>而抽象类&#x2F;类之间的继承都只能是单继承。</p>
<h5 id="6-多态"><a href="#6-多态" class="headerlink" title="6.多态"></a>6.多态</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.hxy.begin;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;I&#x27;m your grandpa : A&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;I&#x27;m your mother : B&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;I&#x27;m your sonC&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;I&#x27;m your sonD&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	A person1=<span class="literal">null</span>;</span><br><span class="line">	person1=<span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//使用A类型变量引用B类型 A-&gt;B向下指，可以直接指</span></span><br><span class="line">	System.out.println(person1.say());</span><br><span class="line">	person1=<span class="keyword">new</span> <span class="title class_">C</span>();<span class="comment">//使用A类型变量引用C类型</span></span><br><span class="line">	System.out.println(person1.say());</span><br><span class="line">	person1=<span class="keyword">new</span> <span class="title class_">D</span>();<span class="comment">//使用A类型变量引用D类型</span></span><br><span class="line">	System.out.println(person1.say());</span><br><span class="line">	System.out.println(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">	B person2=(B)person1;<span class="comment">//向下转型，可以看作将person2指向person1，即向上指的时候，因为是向上指，所以要将被指对象降级再转型</span></span><br><span class="line">	System.out.println(person2.say());<span class="comment">//调用方法还是由实际类型决定</span></span><br><span class="line">	C person3=(C)person2;  </span><br><span class="line">	System.out.println(person3.say());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211002220803446.png" alt="image-20211002220803446" style="zoom:100%;" />

<p>错误原因：编译时，检测的是变量的声明类型，即B类型向下转化为C类型，但再运行时，转换的是变量的实际类型，即D类型到C类型的转换，而C&amp;D类型之间并没有关联，故不能通过强转实现转换。</p>
<h4 id="包（package）"><a href="#包（package）" class="headerlink" title="包（package）"></a>包（package）</h4><h5 id="1-关于包"><a href="#1-关于包" class="headerlink" title="1.关于包"></a>1.关于包</h5><ul>
<li><p>包的定义：形式上：是一组相关类和接口的集合       功能上:是区别类的名字空间的机制（不同包中类的名字可以相同，提高了复用性）</p>
</li>
<li><p>包的规范：（三个一）  </p>
<p><strong>一</strong>般都小写；必须是程序代码中的第<strong>一</strong>行可执行代码；package语句最多只能<strong>一</strong>句；</p>
<p>命名规则：公司域名反转作为包名（略）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>带包编译命令</span><br><span class="line"><span class="comment">//引言：之前手动编译时，我们先将包对应的目录文件夹一个个手动创建好，在再其中写一个java源文件，然后编译运行</span></span><br><span class="line"><span class="comment">//实际上这一切都可以用命令提示符完成，只需提前将package写入java文件</span></span><br><span class="line"><span class="keyword">package</span> pers.hxy.helloworld</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hahaha&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.使用 javac -d.Person.java 编译源文件</span></span><br><span class="line"><span class="comment">//-d表示生成包对应的目录，.表示编译好的字节码文件放入当前文件夹中</span></span><br><span class="line"><span class="comment">//使用java pers.hxy.helloworld.Person运行命令(采用包名.类名的方法：可以理解为先切换到源文件所在的目录)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//java应用程序打包  </span></span><br><span class="line"><span class="comment">//更方便的给别人使用</span></span><br><span class="line"><span class="comment">//在要打包的顶层目录的上一级目录打开命令行窗口</span></span><br><span class="line">jar -cvf xxx.jar <span class="title function_">pers</span><span class="params">(顶层目录名)</span></span><br><span class="line"><span class="comment">//然后添加环境变量，就over了</span></span><br><span class="line">set classpath=.;D:\新建文件夹\helloword\src\xxx.jar  相关路径</span><br><span class="line"><span class="comment">//补充：解压包命令(解压到当前目录)</span></span><br><span class="line">jar -xvf xxx.jar</span><br></pre></td></tr></table></figure>

<h5 id="2-import语句"><a href="#2-import语句" class="headerlink" title="2.import语句"></a>2.import语句</h5><p>public所修饰的类允许跨包使用，但必须引入该类所在的包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入位置：package语句之下，类定义之上</span></span><br><span class="line"><span class="comment">//两种引入形式</span></span><br><span class="line"><span class="comment">//1.引入类： 1个或多个  不能只导入包名</span></span><br><span class="line"><span class="keyword">import</span> 包名.类名</span><br><span class="line"><span class="keyword">import</span> 包名.*</span><br><span class="line"><span class="comment">//2.加static引入某个类的静态成员/方法  一个/多个     不能只导入类名</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> 包名.类名.成员名</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> 包名.类名.*</span><br><span class="line">    <span class="comment">//注意：直接用import static引入静态变量之后，直接使用变量即可，无需加类名调用（你又没有引入该类:)）</span></span><br></pre></td></tr></table></figure>

<h5 id="3-java常用包（内置的）"><a href="#3-java常用包（内置的）" class="headerlink" title="3.java常用包（内置的）"></a>3.java常用包（内置的）</h5><p>java.lang：核心包（如String,Math,System等），系统自动导入，无需手动</p>
<p>java.util：工具包</p>
<h5 id="4-Lambda-表达式"><a href="#4-Lambda-表达式" class="headerlink" title="4.Lambda 表达式"></a>4.Lambda 表达式</h5><p>1.关于Lambda 表达式</p>
<p>实际上就是js中的箭头函数，只是&#x3D;&gt;  变成了-&gt;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关于箭头函数的讲解（我的理解：匿名函数的变形）</span></span><br><span class="line">(a,b)-&gt;&#123;a-b&#125; <span class="comment">//括号中是参数列表，参数类型可省略，若只有一个参数，则可以不加括号</span></span><br><span class="line">   			 <span class="comment">//&#123;&#125;中是函数体，若只有一条语句，&#123;&#125;、return 都可以省略</span></span><br><span class="line">			 <span class="comment">//其他省就省了，为啥return关键字也可以被省略呢？原因是，编译器会认为：既然只有一个语句，那么这个语句执行的结果就				应该是返回值，所以return也就不需要了。</span></span><br></pre></td></tr></table></figure>

<p>2.Lambda 表达式的意义</p>
<p><u><strong>简化某些接口的实现（函数式接口）</strong></u>，**<u>实际上是简化某些接口中抽象函数的实现</u>**</p>
<p>在以前，我们实现一个接口的抽象方法，需要用一个类去实现，非常麻烦</p>
<p>而对于：**<u>函数式接口 ：仅包含一个抽象方法</u>**(ps:但是可以包含多个非抽象方法：静态方法，默认方法），则可以直接用Lambda 表达式实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ServiceOne</span>&#123;</span><br><span class="line">    <span class="comment">//唯一一个抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printmessage</span><span class="params">(String message)</span>;</span><br><span class="line">    <span class="comment">//默认方法不是抽象方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">pringMessage2</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Testlam</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//实现ServiceOne接口</span></span><br><span class="line">		ServiceOne service1=s-&gt;System.out.println(s); <span class="comment">//实现直接打印功能</span></span><br><span class="line">        ServiceOne service2=s-&gt;System.out.println(s+<span class="string">&quot;!&quot;</span>);<span class="comment">//实现打印且加感叹号功能</span></span><br><span class="line">        ServiceOne service3=s-&gt;System.out.println(s+<span class="string">&quot;haha&quot;</span>);<span class="comment">//实现打印且加haha功能</span></span><br><span class="line">        service1.printmessage(<span class="string">&quot;I&#x27;m your father &quot;</span>);</span><br><span class="line">        service2.printmessage(<span class="string">&quot;I&#x27;m your father &quot;</span>);</span><br><span class="line">        service3.printmessage(<span class="string">&quot;I&#x27;m your father &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//I&#x27;m your father </span></span><br><span class="line"><span class="comment">//I&#x27;m your father !</span></span><br><span class="line"><span class="comment">//I&#x27;m your father haha</span></span><br></pre></td></tr></table></figure>

<p>我们发现通过lambda表达式，可以直接实例化一个ServiceOne接口对象，且该接口中的抽象方法已经被填充！！！</p>
<p><strong>通过Lambda表达式，可以实例化一个接口对象，且为其实现抽象方法，不同接口对象，可以实现不同方法。</strong></p>
<p>不同对象调用同一方法名，实现不同功能（怎么有股多态那味儿）</p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><h5 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h5><ul>
<li>异常是一个在程序执行期间发生的事件，它中断了正在执行程序的正常指令流。</li>
</ul>
<h5 id="2-异常类别"><a href="#2-异常类别" class="headerlink" title="2.异常类别"></a>2.异常类别</h5><p>java将异常封装到一个类中，出现错误时，会抛出异常。</p>
<blockquote>
<p>Java类库中定义了异常类，他们都是Throwable的子类。即：Exception(异常)&amp;Error(错误)  各自都包含大量子类</p>
<ul>
<li><p>Error:程序无法处理的错误。描述了运行系统的内部错误，以及资源耗尽的问题。由JVM抛出。大多与代码编者本身无关。</p>
</li>
<li><p>Exception:程序本身可以处理的异常。</p>
<ul>
<li><p>RuntimeException(运行时异常)：运行期间，JVM抛出的异常，如那些：可以通过语法检测，但是最终在控制台报错。</p>
<p>（此类错误常常能准确定位到发生错误的代码段，通过错误调试解决）</p>
</li>
<li><p>CheckedException(可检查异常)：编译期间出现异常。必须进行处理。也就是写代码出现红线的错误</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="3-异常的处理！！！"><a href="#3-异常的处理！！！" class="headerlink" title="3.异常的处理！！！"></a>3.异常的处理！！！</h5><img src="https://img-blog.csdnimg.cn/20190316111318681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1Z2FyX25vMQ==,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 67%;" />



<ul>
<li><h6 id="try-catch处理异常"><a href="#try-catch处理异常" class="headerlink" title="try-catch处理异常"></a>try-catch处理异常</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThrow2</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">		<span class="comment">//if(b==0) &#123;</span></span><br><span class="line">			<span class="comment">//throw new ArithmeticException(&quot;不能输入零！！！&quot;);</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">		<span class="keyword">return</span> a/b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//若发现异常，则将产生的异常对象抛出</span></span><br><span class="line">			<span class="type">int</span> val=div(<span class="number">10</span>, <span class="number">0</span>);    <span class="comment">//若该步发生了异常，则将跳过后续代码，直接进入catch，</span></span><br><span class="line">			System.out.println(val);</span><br><span class="line">            <span class="comment">//若try中抛出的异常对象类型符合，catch中定义的，则传入相应的catch中</span></span><br><span class="line">		&#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">			System.out.println(e);</span><br><span class="line">            System.out.println(e.getMessage());<span class="comment">//getMessage():Throwable常用方法:异常对象信息</span></span><br><span class="line">			System.out.println(e.toString());<span class="comment">//toString() :Throwable常用方法:返回异常类全名及异常对象信息</span></span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">/*xxx代码*/</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//		int val=div2(10, 0);</span></span><br><span class="line"><span class="comment">//		System.out.println(val);</span></span><br><span class="line">		System.out.println(<span class="string">&quot;hah&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line">    <span class="comment">//java.lang.ArithmeticException: 不能输入零！！！</span></span><br><span class="line">	<span class="comment">//不能输入零！！！</span></span><br><span class="line">    <span class="comment">//java.lang.ArithmeticException: 不能输入零！！！</span></span><br><span class="line">	<span class="comment">//hah        --&gt;接使用异常处理的意义</span></span><br><span class="line"><span class="comment">//讲解：</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能会发生的异常的程序代码</span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">1</span> e1 )&#123;</span><br><span class="line">    针对异常进行处理的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> e2)&#123;</span><br><span class="line">    针对异常进行处理的代码</span><br><span class="line">&#125;...</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">   释放资源代码；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于finally</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取部分代码：</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">int</span> val=div(<span class="number">10</span>, <span class="number">0</span>);   </span><br><span class="line">			System.out.println(val);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">			System.out.println(e);</span><br><span class="line">			System.out.println(e.toString());</span><br><span class="line">    		<span class="comment">//System.exit(0);  jvm退出指令</span></span><br><span class="line">    		<span class="keyword">return</span> a  <span class="comment">//只是为了测试，随便乱返回一个</span></span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    		a++;</span><br><span class="line">            system.out.println(<span class="string">&quot;ha&quot;</span>);  </span><br><span class="line">    <span class="comment">//此时finally代码仍会执行，就算不发生异常，finally也会执行，所以：finally里面的代码最终一定会执行（除了JVM退出）</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//try中处理return的机制:先保存return值，在执行finally，再取出保存值（也就是说：a会变，但原来的值已经被保存了）</span></span><br><span class="line"><span class="comment">//最终返回的return值仍为1</span></span><br></pre></td></tr></table></figure>
</li>
<li><h6 id="关于异常的嵌套"><a href="#关于异常的嵌套" class="headerlink" title="关于异常的嵌套"></a>关于异常的嵌套</h6></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由上面代码可知：只要try中发现异常对象，则立刻跳过try中后续代码，进入到相应的catch中，</span></span><br><span class="line"><span class="comment">//故若一个try中包含多个异常，则只能捕获出一种（其他可能出错的程序，都被跳过了）,想要捕获到几种，则要采用嵌套</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">work1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">chu</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a/b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">say</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> s[<span class="number">5</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//异常嵌套：使可捕获到多种错误</span></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//先测试下标越界</span></span><br><span class="line">					<span class="type">char</span>[] strs= &#123;<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">					System.out.println(say(strs));</span><br><span class="line">					&#125;<span class="keyword">catch</span>(IndexOutOfBoundsException e2) &#123;</span><br><span class="line">						System.out.println(e2);</span><br><span class="line">					&#125;</span><br><span class="line">                <span class="comment">//再测试算数异常</span></span><br><span class="line">				<span class="type">int</span> c=chu(<span class="number">10</span>, <span class="number">0</span>);  <span class="comment">//上层错误代码一定要放到下层try的下面，不然，下层try的代码将直接被跳过</span></span><br><span class="line">				System.out.println(c);</span><br><span class="line">				&#125;<span class="keyword">catch</span> (ArithmeticException e1)&#123;</span><br><span class="line">					System.out.println(e1);</span><br><span class="line">				&#125;</span><br><span class="line">                <span class="comment">//测试空指针异常</span></span><br><span class="line">				<span class="comment">//字符串未初始化时会抛出空指针异常</span></span><br><span class="line">				String work=<span class="literal">null</span>;</span><br><span class="line">				System.out.println(work.length());</span><br><span class="line">			&#125;<span class="keyword">catch</span>(NullPointerException e3) &#123;</span><br><span class="line">				System.out.println(e3);</span><br><span class="line">			&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;异常处理完毕，程序结束&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-Throws与Throw"><a href="#4-Throws与Throw" class="headerlink" title="4.Throws与Throw"></a>4.Throws与Throw</h5><p><strong>所有系统定义的编译和运行异常（即非自定义的）都可以由系统自动抛出</strong>，如上例：main调用div方法，div方法产生异常，但方法内部并没有处理异常的代码，故自动将异常对象抛出调用者——&gt;main，main中有处理异常的方法，故程序正常运行。</p>
<p>如果是多级调用，则将从异常产生处一层层抛出，直到可处理异常的方法中，若到了主函数还没有，则由虚拟机进行处理，程序中断。</p>
<ul>
<li><p><strong>Throws关键字用于抛出异常对象</strong></p>
<p><strong>Throws的意义就是向我们声明：如果该方法产生异常，该方法不处理异常，由他的调用者帮忙处理</strong></p>
</li>
<li><p><strong>Throw关键字用于抛出异常的实例对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式：</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> 异常对象（）;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> 异常对象（<span class="string">&quot;xxx&quot;</span>）;  通过<span class="keyword">throw</span>方式还可以自定义异常对象信息</span><br></pre></td></tr></table></figure>

<p>作用：1.指明此处一定有异常对象（这点实际上没多大用，因为系统定义的异常都会被自动抛出）</p>
<p>2.有些错误jvm看来不是错误，我们可以自己手动引发错误！！来提醒其他开发者</p>
</li>
</ul>
<h5 id="5-自定义异常"><a href="#5-自定义异常" class="headerlink" title="5.自定义异常"></a>5.自定义异常</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.hxy.begin;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DivException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">DivException</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();  <span class="comment">//可以不用写，默认会调用父类的无参构造</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">DivException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(message);  <span class="comment">//实例化有参子类时，调用父类的有参构造</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThrow</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> <span class="keyword">throws</span> DivException&#123;<span class="comment">//手动抛出该实例（自定义异常对象不能被自动抛出）</span></span><br><span class="line">		<span class="keyword">if</span>(b==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DivException</span>(<span class="string">&quot;错误，除数不能为0&quot;</span>);  <span class="comment">//产生异常对象实例，并定义了异常对象信息</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a/b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">int</span> val=div(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">			System.out.println(val);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;    <span class="comment">//因为Exception是所有异常类的父类，所以用其捕获该异常对象</span></span><br><span class="line">			System.out.println(e);</span><br><span class="line">			System.out.println(e.toString());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">pers.hxy.begin.DivException: 错误，除数不能为<span class="number">0</span></span><br><span class="line">pers.hxy.begin.DivException: 错误，除数不能为<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>对于自定义的异常对象，需要手动产生，手动抛（当然不想抛，就在产生实例的那个方法中处理异常呗）</p>
<h5 id="6-总结：使用异常处理的意义"><a href="#6-总结：使用异常处理的意义" class="headerlink" title="6.总结：使用异常处理的意义"></a>6.总结：使用异常处理的意义</h5><p>由第一个代码例中我们发现，尽管产生了异常，但由于我们使用try-catch进行了捕获操作，程序仍然完整执行了（hah被输出，如果没有异常处理，则程序在异常的那一步则直接终止）。</p>
<p><strong>异常处理机制能让程序在异常发生时，按照代码的预先设定的异常处理逻辑，针对性地处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。</strong></p>
<h4 id="基础类库（java自带的类）"><a href="#基础类库（java自带的类）" class="headerlink" title="基础类库（java自带的类）"></a>基础类库（java自带的类）</h4><h5 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h5><p>基于正则表达式的文本扫描器，功能：获取动态传入的参数值</p>
<p>有多个构造方法，用于接收不同的数据来源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="comment">//Scanner类位于java.util包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">//System.in代表标准输入，即键盘输入</span></span><br><span class="line">	Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="comment">//hasNext() 如果当前输入流还有值，则返回true,没有则暂停，等待键入</span></span><br><span class="line">    <span class="comment">//用hasNext()作判段条件，输入流有值则执行，无值将等待输入，有了又执行，然后相当于程序永远不会终止，直到输入exit</span></span><br><span class="line">    <span class="keyword">while</span>(sc.hasNext())&#123;</span><br><span class="line">        <span class="comment">//next()如果当前输入流有值，则直接取走一个，没有则程序暂停等待键入</span></span><br><span class="line">        String s=sc.next();</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">&quot;exit&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的内容为：&quot;</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">    sc.close();  <span class="comment">//释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ps:hasNextxxx() xxx可以为Int Long 等代表基本类型的字符串，如果值判断是否包含下一个字符串，则用hasNext()</span></span><br></pre></td></tr></table></figure>

<p>因为system.in属于IO流，一旦打开，它一直在占用资源，因此使用完毕后切记要关闭。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际上上面已经出现了死循环</span></span><br><span class="line"><span class="comment">//hasNext() 程序永远不会终止，一旦有了输入就可以接收然后执行，相当于打开一个接收窗口一直没有关闭</span></span><br><span class="line"><span class="comment">//有些题目，我们会限制输入的条目数，因此可以用条目数作为while终止条件！！</span></span><br><span class="line"><span class="keyword">while</span>(sc.hasNext())&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关于 next() 和 nextLine() 的区别</span></span><br><span class="line">相同：都返回接收到的String</span><br><span class="line"><span class="title function_">nextLine</span><span class="params">()</span> 返回一整行，换言之，直到遇到回车才结束，空格 tab啥的都不影响</span><br><span class="line">next() 仅返回一个词，遇到空格 tab（开头的除外，会被忽略） 回车都会结束</span><br><span class="line"><span class="comment">//一般推荐使用next（）接收字符串，使用line还得二次处理，分割啥的</span></span><br></pre></td></tr></table></figure>



<h5 id="System类与Runtime类"><a href="#System类与Runtime类" class="headerlink" title="System类与Runtime类"></a>System类与Runtime类</h5><p>java可以通过 **System类与Runtime类中的属性方法 **与程序的系统平台进行信息的交互</p>
<p>但<strong>程序不能创建System类与Runtime类的对象</strong></p>
<ul>
<li><p>System类</p>
<p>它的属性和方法都是静态的，所以就算不能实例化System对象也不影响调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"><span class="type">long</span> start=System.currentTimeMillis() </span><br><span class="line">     <span class="comment">//返回当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</span></span><br><span class="line">    <span class="comment">//返回值为long类型</span></span><br><span class="line">String name=System.getProperty(String key)<span class="comment">//注意传入的是字符串</span></span><br><span class="line">    <span class="comment">//通过键获取当前系统属性中键KEY对应的值</span></span><br><span class="line">    <span class="comment">//如：</span></span><br><span class="line">    System.getProperty(<span class="string">&quot;user.name&quot;</span>); <span class="comment">//当前系统用户名为           Lenovo</span></span><br><span class="line">    System.getProperty(<span class="string">&quot;user.dir&quot;</span>);   <span class="comment">//当前用户工作目录</span></span><br><span class="line">    System.getProperty(<span class="string">&quot;os.name&quot;</span>);    <span class="comment">//当前系统名称</span></span><br><span class="line"></span><br><span class="line">System.exit()<span class="comment">//终止当前正在运行的java虚拟机  无返回值 void</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Runtime类</p>
<p>Runtime类代表Java程序的运行时环境  ( JRE&#x3D;JVM+Api  )，每个java程序都有一个与之对应的Runtime实例</p>
<p>Runtime类的属性和方法不都是静态的，所以<strong>需要通过静态函数getRuntime()方法创建对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过静态函数getRuntime()方法获取当前java程序的Runtime对象</span></span><br><span class="line">Runtime r=Runtime.getRuntime();</span><br><span class="line"><span class="type">long</span> start=r.freeMemory();<span class="comment">//返回Java虚拟机中的空闲内存量</span></span><br><span class="line">		  =r.totalMemory();<span class="comment">//返回Java虚拟机中的总内存量</span></span><br><span class="line">		  =r.maxMemory();<span class="comment">//返回Java虚拟机中的可用最大内存量</span></span><br><span class="line"></span><br><span class="line">r.exec(<span class="string">&quot;xxx&quot;</span>) <span class="comment">//单独的进程中执行指定的字符串命令</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h5><p>Math类包含了许多数学运算的方法。且基本都是<strong>静态</strong>的。</p>
<p>Math类的构造方法是私有的，所以<strong>不能被实例化；</strong></p>
<p>Math类被final修饰，因此<strong>不能有子类。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;  <span class="comment">//Math位于lang包中</span></span><br><span class="line"><span class="comment">//列几个常见的</span></span><br><span class="line"><span class="comment">//Math类提供了两个静态常量E（自然对数）、 PI（圆周率）</span></span><br><span class="line">Math.E <span class="comment">//2.718281828459045</span></span><br><span class="line">Math.PI<span class="comment">//3.141592653589793</span></span><br><span class="line"><span class="comment">//以下三个方法只能用于Int型</span></span><br><span class="line">Math.abs(-<span class="number">10</span>)  <span class="comment">//10绝对值函数</span></span><br><span class="line">Math.max(<span class="number">10</span>,<span class="number">6</span>)  <span class="comment">//10  最大值函数</span></span><br><span class="line">Math.min(<span class="number">10</span>,<span class="number">6</span>)  <span class="comment">//6   最小值函数</span></span><br><span class="line"></span><br><span class="line">Math.random(); <span class="comment">//产生[0,1)的double型随机数</span></span><br></pre></td></tr></table></figure>



<h5 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h5><p>用于生成一个伪随机数，范围更加广</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有两个构造函数</span></span><br><span class="line">Random r=<span class="keyword">new</span> <span class="title class_">Random</span>();  <span class="comment">//无参构造，以当前时间作为种子，相当于每次的种子都不一样，故每次生成随机数不一样</span></span><br><span class="line">Random r=<span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">10</span>);  <span class="comment">//传一个指定参数作为种子，每次生成随机数一样</span></span><br><span class="line"></span><br><span class="line">r.nextDouble() <span class="comment">//返回一个0.0~1.0之间的double型随机数，</span></span><br><span class="line">r.nextDouble()*<span class="number">100</span><span class="comment">//返回一个0~100之间的double型随机数，</span></span><br><span class="line">r.nextFloat() <span class="comment">//返回一个0.0~1.0之间的Float型随机数，</span></span><br><span class="line">r.nextInt()   <span class="comment">//返回一个int</span></span><br><span class="line">r.nextInt(n)   <span class="comment">//返回一个[0,n)之间的Int</span></span><br></pre></td></tr></table></figure>



<h5 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建日期的方式</span></span><br><span class="line"><span class="keyword">import</span> java.util.Date</span><br><span class="line">Date date1=<span class="keyword">new</span> <span class="title class_">Date</span>();  <span class="comment">//调用空构造方法，创建当前日期</span></span><br><span class="line">Date date2=<span class="keyword">new</span> <span class="title class_">Date</span>(xxxxxxxxxx);  <span class="comment">//返回距离1970 1/1 00:00 xxxxxxxxxx毫秒的日期</span></span><br></pre></td></tr></table></figure>



<h5 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h5><p>Calendar类是<strong>抽象类</strong>，<strong>不能被实例化</strong> ，<strong>可以通过静态方法getInstance()获取实例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Calendar类提供了关于当前日期的静态常量！！</span></span><br><span class="line"><span class="comment">//YEAR   MONTH   DAY_OF_MONTH   HOUR_OF_DAY   MINUTE   SECOND   MILLISEECOND</span></span><br><span class="line"><span class="comment">// 年      月         日              时          分       秒          毫秒</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述常量使用时不能直接使用，必须通过get()方法获取！但get()方法需要实例对象调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line">Calendar calendar=Calendar.getInstance();  <span class="comment">//通过getInstance()静态方法获取Calendar实例</span></span><br><span class="line">System.out.println(calendar.get(Calendar.YEAR)); <span class="comment">//通过get()方法得到常量值</span></span><br><span class="line">System.out.println(calendar.get(Calendar.MONTH));		System.out.println(calendar.get(Calendar.DAY_OF_MONTH));		System.out.println(calendar.get(Calendar.HOUR_OF_DAY));</span><br></pre></td></tr></table></figure>



<h5 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h5><p>DateFormat类是<strong>抽象类，不能被实例化，可以4种通过静态方法获取，不同风格的日期&#x2F;时间格式器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取日期格式器</span></span><br><span class="line">DateFormat dateFormat=DateFormat.getDateInstance();</span><br><span class="line"><span class="comment">//利用格式器将时间日期格式化</span></span><br><span class="line">dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>())；  <span class="comment">//2021年10月15日</span></span><br><span class="line"><span class="comment">//获取时间格式器</span></span><br><span class="line">DateFormat dateFormat2=DateFormat.getTimeInstance();</span><br><span class="line">dateFormat2.format(<span class="keyword">new</span> <span class="title class_">Date</span>())   <span class="comment">//下午4:45:39</span></span><br></pre></td></tr></table></figure>



<h5 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h5><p>DateFormat类的子类，可以直接使用父类格式方法 format()</p>
<p>作用：创建实例时，<strong>指定格式器的格式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);<span class="comment">//创建年月日格式为 xxxx-xx-xx 的格式器 如：2021-10-05</span></span><br><span class="line">SimpleDateFormat sdf2=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;Gyyyy-MM-dd hh:mm:ss:SSS&quot;</span>);<span class="comment">//G表示公元  公元2021-10-05 05:44:18:538  SSS表毫秒</span></span><br><span class="line">System.out.println(sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>()); <span class="comment">//2021-10-15</span></span><br></pre></td></tr></table></figure>







<h5 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h5><blockquote>
<p>关于拼接问题：</p>
<p>字符是char 类型，字符串是String 类型<br>1、<strong>数字拼接char，得到的还是数字</strong>，相当于和它的ASCII编码相加（如果定义成String 会编译错误）<br>2、<strong>数字拼接String，得到的是String</strong><br>3、数字同时拼接char 和 String，就看和谁先拼接，和谁后拼接<br>4、<strong>String 拼接任何类型，得到的都是String</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(arr[<span class="number">0</span>]+<span class="string">&quot; &quot;</span>+arr[<span class="number">1</span>]);<span class="comment">//数字拼接字符会变成acii码相加，仍然是数字，所以像这种输出带空格的一定要用字符串包裹</span></span><br></pre></td></tr></table></figure>

<h6 id="1-String类的初始化"><a href="#1-String类的初始化" class="headerlink" title="1.String类的初始化"></a>1.String类的初始化</h6><p><u>关于String类：String类表示不可变的字符串，一旦其被创建，对象中的字符序列就不能再被改变。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.直接赋值初始化</span></span><br><span class="line">String s1=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">//JVM首先会去常量池中查找是否存在&quot;abc&quot;这个对象，如果不存在，则在常量池中创建&quot;abc&quot;这个对象，然后将池中&quot;abc&quot;这个对象的引用地址返回给&quot;abc&quot;对象的引用s1，这样s1会指向字符串常量池中&quot;abc&quot;这个字符串对象；如果存在，则不创建任何对象，直接将池中&quot;abc&quot;这个对象的地址返回，赋给引用s1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.构造方法初始化</span></span><br><span class="line">String s2=<span class="keyword">new</span> <span class="title class_">String</span>();  <span class="comment">//初始化一个空字符对象</span></span><br><span class="line">String s3=<span class="keyword">new</span> <span class="title class_">String</span>([<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>]);  <span class="comment">//新建一个String对象，字符序列为字符数组当前包含的字符</span></span><br><span class="line">String s4=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xyz&quot;</span>)           <span class="comment">//新建一个String对象</span></span><br><span class="line"><span class="comment">//采用new关键字新建一个字符串对象时，JVM首先在常量池中查找有没有&quot;xyz&quot;这个字符串对象，如果有，则不在池中再去创建&quot;xyz&quot;这个对象了，直接在堆中创建一个&quot;xyz&quot;字符串对象，然后将堆中的这个&quot;xyz&quot;对象的地址返回赋给引用s3，这样，s3就指向了堆中创建的这个&quot;xyz&quot;字符串对象；如果没有，则首先在字符串池中创建一个&quot;xyz&quot;字符串对象，然后再在堆中创建一个&quot;xyz&quot;字符串对象，然后将堆中这个&quot;xyz&quot;字符串对象的地址返回赋给s3引用。s4则指向了堆中创建的另一个&quot;xyz&quot;字符串对象。s3 、s4是两个指向不同对象的引用，故s3!=s4。</span></span><br></pre></td></tr></table></figure>

<h6 id="2-String类常用方法"><a href="#2-String类常用方法" class="headerlink" title="2.String类常用方法"></a>2.String类常用方法</h6><p>由于String类表示不可变的字符串,故大多都是 用于判段、获取信息、得到一个新的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">&quot;hello.com&quot;</span>;</span><br><span class="line"><span class="comment">//字符串长度获取</span></span><br><span class="line"><span class="type">int</span> len=str.length();</span><br><span class="line"><span class="comment">//利用索引获取该位置的值</span></span><br><span class="line">System.out.println(str.charAt(<span class="number">1</span>));<span class="comment">//e  </span></span><br><span class="line"><span class="comment">//按指定符号分隔，拆成字符串数组</span></span><br><span class="line">String[] sp=str.split(<span class="string">&quot;\\.&quot;</span>) <span class="comment">//先将.转义为 \. 再将\转义\\  注意：split中的参数一定是string型 </span></span><br><span class="line">System.out.println(sp[<span class="number">0</span>]); <span class="comment">//hello</span></span><br><span class="line">System.out.println(sp[<span class="number">1</span>]); <span class="comment">//com</span></span><br><span class="line"><span class="comment">//字符串截取</span></span><br><span class="line">System.out.println(str.substring(<span class="number">2</span>));<span class="comment">//llo  从索引2截取到末尾</span></span><br><span class="line">System.out.println(str.substring(<span class="number">2</span>,<span class="number">4</span>)); <span class="comment">//ll  截取2，3号位</span></span><br><span class="line"><span class="comment">//大小写转换</span></span><br><span class="line">String str1=str.toUpperCase(); </span><br><span class="line">System.out.println(str1);<span class="comment">//HELLO.COM</span></span><br><span class="line">String str2=str.toLowerCase();</span><br><span class="line">System.out.println(str2);<span class="comment">//hello.com</span></span><br><span class="line"><span class="comment">//replace完成字符串中的字符--字符/字符串--字符串替换，替换全部的</span></span><br><span class="line">String newstr=str.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;#&#x27;</span>);  <span class="comment">//hello#com </span></span><br><span class="line"><span class="comment">//replaceAll 替换此字符串所有匹配给定的正则表达式的子字符串，见上方</span></span><br><span class="line"><span class="comment">//replaceFirst 替换第一个匹配的，即可用于匹配的字符串替换，也可用于匹配的正则表达式</span></span><br><span class="line">System.out.println(newstr);</span><br><span class="line"><span class="comment">//将字符串转化为一个字符数组</span></span><br><span class="line"><span class="type">char</span>[] c=str.toCharArray(); </span><br><span class="line"><span class="comment">//判段是否包含某子串：</span></span><br><span class="line"><span class="type">boolean</span> has=str.contains(<span class="string">&quot;llo&quot;</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关于字符串的比较问题：equals(xxx)   VS    ==</span></span><br><span class="line"><span class="comment">//equals() 比较的是字符串的内容是否相同，这正是我们需要的</span></span><br><span class="line"><span class="comment">//==  比较的是字符串的地址是否相同</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);   		<span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.equals(s2));      <span class="comment">//true   </span></span><br><span class="line">&#125;</span><br><span class="line">因为他们的地址都是常量池中<span class="string">&quot;hello&quot;</span>对象的引用地址，所以s1==s2</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;HELLO&quot;</span>.toLowerCase();</span><br><span class="line">        System.out.println(s1 == s2);               <span class="comment">//false</span></span><br><span class="line">        System.out.println(s1.equals(s2));          <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h5><p><u>StringBuffer用于描述可变序列。不用生成新的对象，可在原来序列上修改</u></p>
<h6 id="StringBuffer类常用方法（包含String类，这里不重复写）"><a href="#StringBuffer类常用方法（包含String类，这里不重复写）" class="headerlink" title="StringBuffer类常用方法（包含String类，这里不重复写）"></a>StringBuffer类常用方法（包含String类，这里不重复写）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String转StringBuffer</span></span><br><span class="line">StringBuffer sb=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hh&quot;</span>);</span><br><span class="line"><span class="comment">//1.末尾追加内容</span></span><br><span class="line">sb.append(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;just&quot;</span>);</span><br><span class="line">sb.append(<span class="number">1</span>);</span><br><span class="line">System.out.println(sb); <span class="comment">//hha  just</span></span><br><span class="line"><span class="comment">//2.指定位置加入内容</span></span><br><span class="line">sb.insert(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">System.out.println(sb);  <span class="comment">//hhaa  just</span></span><br><span class="line"><span class="comment">//3.字符串反转</span></span><br><span class="line">sb.reverse();  <span class="comment">//tsuj  aahh</span></span><br><span class="line"><span class="comment">//4.删除指定范围字符串</span></span><br><span class="line">sb.delete(<span class="number">4</span>,<span class="number">5</span>);  <span class="comment">//tsujaahh</span></span><br></pre></td></tr></table></figure>



<h5 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h5><p>StringBuffer是线程安全的，而StringBuilder是线程不安全的，故其效率更高</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p><strong>多线程</strong>：一个进程在执行过程中产生多个更小的程序单元，称为线程</p>
<p>每个运行的程序就是进程，进程可以同时执行多个任务，每个任务就是线程。</p>
<p>进程在系统中独立存在，多个进程可以在单个处理器上并发执行且互不影响。</p>
<h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><blockquote>
<p>输入：从外部存储–&gt;程序     输出：程序–&gt;外部存储</p>
<p>抽象类OutputStream 是一切字节输出流的基类，InputStream是一切字节输入流的基类</p>
</blockquote>
<h5 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> pers.hxy.begin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Testio</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		<span class="comment">//创建字节输出流对象（使用outputStream的子类）</span></span><br><span class="line">		FileOutputStream io1=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//若想实现追加写入，即每一次运行都会接着上面的写，而不是从头开始重新写，</span></span><br><span class="line"><span class="comment">//		FileOutputStream io1=new FileOutputStream(&quot;hello.txt&quot;,true); //将从末尾开始追加</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//三种写出方式</span></span><br><span class="line">		<span class="comment">//1.一次性只写一个int 自动根据ascII码转化为字符</span></span><br><span class="line">		io1.write(<span class="number">97</span>);  <span class="comment">//a    </span></span><br><span class="line">		<span class="type">byte</span>[] by= &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>&#125;;  </span><br><span class="line">        </span><br><span class="line">		<span class="comment">//2.一次性写入一个字节数组</span></span><br><span class="line">		io1.write(by);   <span class="comment">//abcd   </span></span><br><span class="line">		<span class="comment">//小tips可以自动将想输入内容转换成字节数组，再传入</span></span><br><span class="line">		<span class="type">byte</span>[] by2=<span class="string">&quot;whoYouWANT&quot;</span>.getBytes();</span><br><span class="line">		io1.write(by2);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//2.1 写入一部分数据</span></span><br><span class="line">		io1.write(by2,<span class="number">0</span>,<span class="number">2</span>); <span class="comment">//wh 从0开始写2个</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//写数据的时候想换行怎么办？</span></span><br><span class="line">		io1.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());   <span class="comment">//想在windows下识别换行：\r\n </span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//释放资源，关闭输出流</span></span><br><span class="line">		io1.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h5 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字节输入流</span></span><br><span class="line"><span class="keyword">package</span> pers.hxy.begin;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Testio</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		<span class="comment">//创建字节输入流对象（使用InputStream的子类）</span></span><br><span class="line">		FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//读取数据</span></span><br><span class="line">		<span class="comment">//1.读取一个数据  注意：不管什么流，用.read（）返回的都是int类类型</span></span><br><span class="line">		<span class="type">int</span> b=fis.read(); </span><br><span class="line">		System.out.println((<span class="type">char</span>)b); <span class="comment">//a</span></span><br><span class="line">		System.out.println(b);     <span class="comment">//97</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//1.1.常用：读取全部数据</span></span><br><span class="line">		<span class="type">int</span> by;</span><br><span class="line">		<span class="keyword">while</span>((by=fis.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">			System.out.print((<span class="type">char</span>)by);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.一次性读取定长的数据（用指定长度的字节数组去装读取的数据，只能读取这么多）</span></span><br><span class="line">        <span class="type">byte</span>[] bys=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">		<span class="type">int</span> len;</span><br><span class="line">		len=fis.read(bys); <span class="comment">//len:此时read()返回实际读取的字节数，读取到的数据存在了bys中</span></span><br><span class="line">		System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bys,<span class="number">0</span>,len)); <span class="comment">//将字节数组转换为对应的字符串</span></span><br><span class="line">		System.out.print(bys);</span><br><span class="line">        </span><br><span class="line">        fis.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>实例：复制图片</strong></li>
</ul>
<p><strong>数据源—-&gt;—-读—–&gt;—–程序——&gt;——-写——–&gt;——-目的地</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\2021前端---jQuery\\image\\monster4.png&quot;</span>);</span><br><span class="line">		<span class="comment">//将文件内容复制到D盘下的end文件中</span></span><br><span class="line">		FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;mn.png&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方1：基本字节流一次性读写一个字节</span></span><br><span class="line"><span class="comment">//		int by;</span></span><br><span class="line"><span class="comment">//		while((by=fis.read())!=-1) &#123;        //这种方法最慢！效率最低</span></span><br><span class="line"><span class="comment">//			fos.write(by);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方2：基本字节流一次性读写一个字节数组（1024个字节）</span></span><br><span class="line">		<span class="type">byte</span>[] by=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];          </span><br><span class="line">		<span class="type">int</span> len;             </span><br><span class="line">		<span class="keyword">while</span>((len=fis.read(by))!=-<span class="number">1</span>) &#123; </span><br><span class="line">			fos.write(by,<span class="number">0</span>,len);</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">		fis.close();</span><br><span class="line">		fos.close();</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line"> <span class="comment">//方3：字节缓冲流一次性读写一个字节数组（这种方法最快）</span></span><br><span class="line">    略，就是对输入流和输出流做一个封装，改一下最上面两行代码即可</span><br></pre></td></tr></table></figure>

<h5 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h5><p>实际上就是对<strong>输出流 和 输入流</strong>的一个 <strong>封装</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Testio2</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		BufferedInputStream bin=<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;hello.txt&quot;</span>));</span><br><span class="line">		<span class="type">int</span> len;</span><br><span class="line">		<span class="type">byte</span>[] bys=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">while</span>((len=bin.read(bys))!=-<span class="number">1</span>) &#123;</span><br><span class="line">			System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bys,<span class="number">0</span>,len));</span><br><span class="line">		&#125;</span><br><span class="line">		BufferedOutputStream bos=<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;hello.txt&quot;</span>));</span><br><span class="line">		bos.write(<span class="string">&quot;I LOVE YOU!&quot;</span>.getBytes());</span><br><span class="line">		</span><br><span class="line">		bin.close();</span><br><span class="line">		bos.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h5><p>字符流&#x3D;字节流+编码方式</p>
<p>字符流有两个抽象基类：Writer   Reader</p>
<p>OutputStreamWriter:字符输出流             读取字符，采用指定字符集将其编码为字节</p>
<p>InutputStreamReader:  字符输入流         读取字节，采用指定字符集将其解码为字符（若未指定，则都采用默认字符集UTF-8）</p>
<blockquote>
<p>用字节流操作汉字不是很方便，所以Java提供字符流</p>
<p>一个汉字:  3个字节（UTF-8编码） 2个字节（BGK编码）</p>
<p>无论采用哪种存储方式，第一个字节都是负数</p>
<p>常见编码表：ASCii字符集    GBK字符集（简体中文码表） Unicode(标准万国码)（其中UTF-8是最常用的编码方案）</p>
</blockquote>
<ul>
<li><strong>字符输出流</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Testio2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">//创建一个使用默认字符编码的字符输出流对象</span></span><br><span class="line">         <span class="comment">//构造函数参数必须是OuputStream类</span></span><br><span class="line">		OutputStreamWriter osw=<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;hello.txt&quot;</span>));</span><br><span class="line">		<span class="comment">//直接写一个字符（可以写对应的int）</span></span><br><span class="line">		osw.write(<span class="number">97</span>);</span><br><span class="line">		<span class="comment">//直接传入一个字符串</span></span><br><span class="line">		osw.write(<span class="string">&quot;hahas\n&quot;</span>);</span><br><span class="line">		<span class="comment">//传入字符串的一部分</span></span><br><span class="line">		osw.write(<span class="string">&quot;我爱你&quot;</span>,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">		osw.flush();<span class="comment">//字符流写数据的时候会先累积在缓冲区里面，若想立即写入，则需要手动刷新</span></span><br><span class="line">       </span><br><span class="line">		osw.close();  <span class="comment">//关闭Io流前，会自动进行刷新</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>字符输入流</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Testio2</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//构造函数参数必须是InputStream类</span></span><br><span class="line">		InputStreamReader isr=<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;hello.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//一次读取一个字符</span></span><br><span class="line"><span class="comment">//		int ch;</span></span><br><span class="line"><span class="comment">//		while((ch=isr.read())!=-1) &#123;</span></span><br><span class="line"><span class="comment">//			System.out.print((char)ch);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">        <span class="comment">//一次读取一个字符数组</span></span><br><span class="line">		<span class="type">int</span> len;</span><br><span class="line">		<span class="type">char</span>[] c=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">while</span>((len=isr.read(c))!=-<span class="number">1</span>) &#123;</span><br><span class="line">			System.out.print(String.valueOf(c));</span><br><span class="line">		&#125;</span><br><span class="line">		isr.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符缓冲流</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符缓冲输入流 </span></span><br><span class="line">BufferedReader br=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;hello.txt&quot;</span>));</span><br><span class="line"><span class="comment">//也可以这样：PS:FileReader内置一构造函数生成FileInputStream对象，然后调用父类构造生成Reader类</span></span><br><span class="line"><span class="comment">//BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(&quot;hello.txt&quot;)));</span></span><br><span class="line"><span class="comment">//字符缓冲输出流</span></span><br><span class="line">BufferedWriter bw=<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;hello.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//缓冲流的特有功能</span></span><br><span class="line">bw.newLine();  <span class="comment">//换行</span></span><br><span class="line">br.readLine();<span class="comment">//一次读一行字符</span></span><br><span class="line"></span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line=br.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">	System.out.println(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="关于：JAVA-GUI"><a href="#关于：JAVA-GUI" class="headerlink" title="关于：JAVA GUI"></a>关于：JAVA GUI</h2><p>Graphical User Interface （GUI）图形化的用户界面</p>
<h5 id="1-2Java提供了三个主要包做GUI开发："><a href="#1-2Java提供了三个主要包做GUI开发：" class="headerlink" title="1.2Java提供了三个主要包做GUI开发："></a><strong>1.2Java提供了三个主要包</strong>做GUI开发：</h5><p>java.awt 包 – 主要提供字体&#x2F;布局管理器</p>
<p>javax.swing 包[商业开发常用] – 主要提供各种组件(窗口&#x2F;按钮&#x2F;文本框)</p>
<p>java.awt.event 包 – 事件处理，后台功能的实现。</p>
<p>Swing组件</p>
<p>（1）顶层容器:：常用有JFrame，JDialog  <em>绝大多数Swing图形界面程序使用JFrame作为顶层容器</em></p>
<p>（2）中间容器：JPanel<em>相当于div</em>，JOptionPane，JScrollPane，JLayeredPane 等，主要以panel结尾。</p>
<p>（3）基本组件：JLabel，JButton，JTextField，JPasswordField，JRadioButton 等。 <em>标签、按钮、文本框、密码框、单选按钮</em></p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h4 id="几种整数处理方法"><a href="#几种整数处理方法" class="headerlink" title="几种整数处理方法"></a>几种整数处理方法</h4><h6 id="1-整数逆序问题-123-321"><a href="#1-整数逆序问题-123-321" class="headerlink" title="1.整数逆序问题  ( 123-&gt;321 )"></a>1.整数逆序问题  ( 123-&gt;321 )</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将整数转换为字符串解决</span></span><br><span class="line">/ （整数转换为String再处理）</span><br><span class="line"><span class="type">int</span> num=<span class="number">56289</span>;</span><br><span class="line">StringBuffer s=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(Integer.toString(num));</span><br><span class="line">System.out.println(s.reverse());</span><br><span class="line"><span class="type">int</span> revNum=Integer.valueOf(s); <span class="comment">//将反转的字符串转换为revNum</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于整数构造原理，结合加减乘除构造逆序数</span></span><br><span class="line"><span class="comment">//不转换成字符串将整数反转 得到321的过程 :轮1:0*10+3=3  轮2: 3*10+2=32 轮3: 32*10+1</span></span><br><span class="line"><span class="comment">//对于负数如-123  轮1：0*10+(-3)=-3 轮2：-3*10+(-2)=-32 轮3：-32*10+(-1)=-321</span></span><br><span class="line"><span class="type">int</span> base=<span class="number">0</span>;<span class="comment">//设立base，作为我们每次*10的数</span></span><br><span class="line"><span class="keyword">while</span>(num!=<span class="number">0</span>) &#123;</span><br><span class="line">	base=base*<span class="number">10</span>+num%<span class="number">10</span>;</span><br><span class="line">	num/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(base); <span class="comment">//98265</span></span><br></pre></td></tr></table></figure>

<p>上述代码没有考虑溢出问题，int 的范围是-2147483648 ~ 2147483647 显然逆序的话就会超出范围</p>
<p>给代码前先解决几个问题：</p>
<p>1.溢出的话值会怎么变化？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接赋值的话，java会报超出范围错误，但如果是运算过程中发生溢出的现象，则会*取模*(Mod=<span class="number">2</span>^<span class="number">32</span>=<span class="number">2147483648</span>*<span class="number">2</span>)</span><br><span class="line">如 <span class="type">int</span> a=-<span class="number">2147483648</span>-<span class="number">1</span>;  <span class="comment">//打印：2147483647 就像钟表一样</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一道关于int整形溢出很不错的题目</span></span><br><span class="line"><span class="comment">//-2147483648 ~ 2147483647</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;<span class="comment">//将结果直接设置为int，中途就一定要注意一切可能会发生溢出的问题</span></span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> tail=x%<span class="number">10</span>;</span><br><span class="line">            <span class="comment">//首先位数小的数肯定小，so 位数小于12位的数肯定不会发生溢出，最可能溢出的情况只会是在最后一次乘，即11--&gt;12位的过程中</span></span><br><span class="line">            <span class="keyword">if</span>(res&gt;<span class="number">214748364</span>||res==<span class="number">214748364</span>&amp;&amp;tail&gt;<span class="number">7</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(res&lt;-<span class="number">214748364</span>||res==-<span class="number">214748364</span>&amp;&amp;tail&lt;-<span class="number">8</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            res=res*<span class="number">10</span>+tail;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="2-整数分解问题"><a href="#2-整数分解问题" class="headerlink" title="2.整数分解问题"></a>2.整数分解问题</h6><p>核心：对一个数如623，623%10&#x3D;3 得到尾数，623&#x2F;10&#x3D;62 剥离，62%10&#x3D;2 得到十位 ，62&#x2F;10&#x3D;6 剥离 6%10&#x3D;6 得到百位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将整数分解然后放入数组中</span></span><br><span class="line"><span class="type">int</span>[] res=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> num=<span class="number">13231</span>;</span><br><span class="line"><span class="type">int</span> i=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">while</span>(num!=<span class="number">0</span>) &#123;</span><br><span class="line">	res[i--]=num%<span class="number">10</span>;</span><br><span class="line">	num/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j:res) &#123;</span><br><span class="line">	System.out.println(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="关于二维数组的问题"><a href="#关于二维数组的问题" class="headerlink" title="关于二维数组的问题"></a>关于二维数组的问题</h4><img src="/Users/hxyh/Library/Application Support/typora-user-images/image-20230504004725126.png" alt="image-20230504004725126" style="zoom:50%;" />

<h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>tips 与 收获：</p>
<ol>
<li>二维数组解题是需要判断是否有可能为空数组的情况，因为为空时，matrix[0]越界，获取n值报错</li>
<li>与高效查找相对的是暴力查找，通过这里非递减的特性，可以知道，（i,j)元素的右下角片区的元素均大于该元素，通过寻找到大于target的元素，（其右下方就可以排除）可以确定边界</li>
<li>二维数组解题涉及循环思想，每个循环中都有一个基础点，每次都对基础点进行相同的操作或判断，一般来说基础点是以对角线上的元素</li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p>时间复杂度 O（n²）	空间复杂度 O（1）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//确定边界值</span></span><br><span class="line">        <span class="type">int</span> left=matrix.length;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> right=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;left&amp;&amp;j&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j+k&lt;right&amp;&amp;matrix[i][j+k]&lt;target) k++;</span><br><span class="line">            <span class="keyword">if</span>(j+k&lt;right&amp;&amp;matrix[i][j+k]==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            right=j+k;k=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i+k&lt;left&amp;&amp;matrix[i+k][j]&lt;target) k++;</span><br><span class="line">            <span class="keyword">if</span>(i+k&lt;left&amp;&amp;matrix[i+k][j]==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            left=i+k;</span><br><span class="line">            i+=<span class="number">1</span>;</span><br><span class="line">            j+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Chloe HXY</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2020 LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/05/20/%E6%B5%AE%E4%B8%96%E5%81%B7%E6%B8%A1%20%20%E4%B8%8E%E4%B9%A6/">枕书眠</a>
            
            
            <a class="next" rel="next" href="/2022/04/10/%E5%8D%81%E6%97%A5%E8%B0%88/">十日谈</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Chloe HXY | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>